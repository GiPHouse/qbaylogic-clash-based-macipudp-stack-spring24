diff --git a/clash-eth.cabal b/clash-eth.cabal
index eaeeed0..01ac61e 100644
--- a/clash-eth.cabal
+++ b/clash-eth.cabal
@@ -137,8 +137,6 @@ test-suite test-library
     Test.Lattice.ECP5.UART
     Test.Cores.Ethernet.DownConverter
     Test.Cores.Ethernet.UpConverter
-    Test.Cores.Ethernet.MaybeControl
-    Test.Cores.Ethernet.MaybeControlProperty
     Test.Cores.Ethernet.PacketBuffer
     Test.Cores.Ethernet.InterpacketGapInserter
     Test.Cores.Ethernet.AsyncFIFO
diff --git a/tests/Test/Cores/Ethernet/MaybeControl.hs b/tests/Test/Cores/Ethernet/MaybeControl.hs
deleted file mode 100644
index 63441d3..0000000
--- a/tests/Test/Cores/Ethernet/MaybeControl.hs
+++ /dev/null
@@ -1,209 +0,0 @@
-{-|
-A collection of Hedgehog helpers to test Circuit components. To test a
-protocol component against a combinatorial model, see 'idWithModel'. To write
-your own tester, see 'Test'.
--}
-{-# LANGUAGE UndecidableInstances #-}
-{-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE FlexibleContexts #-}
-
-module Test.Cores.Ethernet.MaybeControl (
-  propWithModelMaybeControl
-  , propWithModelMaybeControlSingleDomain
-) where
-
-
-import Clash.Cores.Ethernet.PacketStream
-
--- base
-import Prelude
-import GHC.Stack (HasCallStack)
-import Data.Proxy (Proxy(Proxy))
-
--- clash-protocols
-import Protocols
-import Protocols.Hedgehog.Internal
-
--- clash-prelude
-import qualified Clash.Prelude as C
-
--- hedgehog
-import qualified Hedgehog as H
-import qualified Hedgehog.Internal.Property as H
-import qualified Hedgehog.Gen as Gen
-import qualified Hedgehog.Range as Range
-
--- pretty print
-import Text.Show.Pretty (ppShow)
-import Data.Maybe
-
-
--- | Whether to stall or not. Used in 'idWithModel'.
-data StallMode = NoStall | Stall
-  deriving (Show, Enum, Bounded)
-
--- | Like 'C.resetGenN', but works on 'Int' instead of 'C.SNat'. Not
--- synthesizable.
-resetGen :: C.KnownDomain dom => Int -> C.Reset dom
-resetGen n = C.unsafeFromHighPolarity
-  (C.fromList (replicate n True <> repeat False))
-
--- | Like propWithModel 
--- returns a list of maybe (Packetstream dom dataWidth metaType) instead of (PacketStream dom dataWidth metaType)
-propWithModelMaybeControl ::
-  forall (dom :: C.Domain) (dataWidth :: C.Nat) (metaType :: C.Type)  .
-  (C.KnownDomain dom) =>
-  (Test (PacketStream dom dataWidth metaType), HasCallStack) =>
-  -- | Options, see 'ExpectOptions'
-  ExpectOptions ->
-  -- | Test data generator
-  H.Gen [PacketStreamM2S dataWidth metaType] ->
-  -- | Model 
-  ([PacketStreamM2S dataWidth metaType] -> [Maybe (PacketStreamM2S dataWidth metaType)]) ->
-  -- | Implementation
-  Circuit (PacketStream dom dataWidth metaType) (PacketStream dom dataWidth metaType)  ->
-  -- | Property to test for. Function is given the data produced by the model
-  -- as (Maybe (PacketStream dom dataWidth metaType)) first argument, and the sampled data as a second argument.
-  ([Maybe (PacketStreamM2S dataWidth metaType)]  -> [Maybe (PacketStreamM2S dataWidth metaType)]  -> H.PropertyT IO ()) ->
-  H.Property
-propWithModelMaybeControl eOpts genData model prot prop = H.property $ do
-  dat <- H.forAll genData
-  let n = maximum (expectToLengths (Proxy @(PacketStream dom dataWidth metaType)) dat)
-
-  let genStall = Gen.integral (Range.linear 0 10)
-
-
-  -- Generate stalls for LHS part of the protocol. The first line determines
-  -- whether to stall or not. The second determines how many cycles to stall
-  -- on each _valid_ cycle.
-  lhsStallModes <- H.forAll (sequenceA (C.repeat @1 genStallMode))
-  lhsStalls <- H.forAll (traverse (genStalls genStall n) lhsStallModes)
-
-  -- Generate stalls for RHS part of the protocol. The first line determines
-  -- whether to stall or not. The second determines how many cycles to stall
-  -- on each _valid_ cycle.
-  rhsStallModes <- H.forAll (sequenceA (C.repeat @1 genStallMode))
-  rhsStalls <- H.forAll (traverse (genStalls genStall n) rhsStallModes)
-
-  let
-    simConfig = def {resetCycles = eoResetCycles eOpts}
-    simDriveConfig =
-      if eoDriveEarly eOpts
-      then def {resetCycles = max 1 (eoResetCycles eOpts - 5)}
-      else def {resetCycles = eoResetCycles eOpts}
-    expected = model dat
-    lhsStallC = stallC simConfig lhsStalls
-    rhsStallC = stallC simConfig rhsStalls
-    drivenProtocol =
-         driveC simDriveConfig (Just <$> dat)
-          |> lhsStallC
-          |> prot
-          |> rhsStallC
-    sampled = sampleC simConfig drivenProtocol
-    lengths = pure $ length expected
-
-  -- testSpecificExpectN errors if circuit does not produce enough data
-  trimmed <- testSpecificExpectN eOpts lengths sampled
-
-  _ <- H.evalNF trimmed
-  _ <- H.evalNF expected
-
-  prop expected trimmed
-
-  where
--- | ExpectN for a model that needs control over the value of maybes
-    testSpecificExpectN ::
-      forall m .
-      (HasCallStack, H.MonadTest m) =>
-      -- | Timeout
-      ExpectOptions -> 
-      -- | Expected number of values  
-      C.Vec 1 Int -> 
-      -- | Sampled data
-      [Maybe (PacketStreamM2S dataWidth metaType)] -> 
-      -- | packaged results
-      m [Maybe (PacketStreamM2S dataWidth metaType)]
-
-    testSpecificExpectN (ExpectOptions{eoEmptyTail, eoTimeout}) (C.head -> nExpected) sampled = do
-      go (fromMaybe maxBound eoTimeout) nExpected 0 sampled
-        where
-        go ::
-          HasCallStack =>
-          -- Timeout counter. If it reaches zero we time out.
-          Int ->
-          -- Expected number of values
-          Int -> 
-          -- Amount of Nothings encountered
-          Int ->
-          -- Sampled data
-          [Maybe (PacketStreamM2S dataWidth metaType)] ->
-          -- Results
-          m [Maybe (PacketStreamM2S dataWidth metaType)]
-
-        go _timeout _n _nothingAm []  =
-          -- This really should not happen, protocols should produce data indefinitely
-          error "unexpected end of signal"
-        go _timeout 0 nothingAm rest = do
-          -- Check for superfluous output from protocol
-          case catMaybes (take eoEmptyTail rest) of
-            [] -> pure (take (nExpected + nothingAm) sampled)
-            superfluous ->
-              let err = "Circuit produced more output than expected:" in
-              H.failWith Nothing (err <> "\n\n" <> ppShow superfluous)
-        go timeout n nothingAm _rest | timeout <= 0 =
-          H.failWith Nothing $ concat
-            [ "Circuit did not produce enough output. Expected "
-            , show n, " more values. Sampled only " <> show (nExpected + nothingAm - n) <> ":\n\n"
-            , ppShow $ catMaybes (take (nExpected + nothingAm - n) sampled)]
-
-        go timeout n nothingAm (Nothing:as) = do
-          -- Circuit did not output valid cycle, increment nothingAmount and continue
-          go (pred timeout) n (succ nothingAm) as
-        go _ n nothingAm (Just _:as) =
-          -- Circuit produced a valid cycle, reset timeOut
-          go (fromMaybe maxBound eoTimeout) (pred n) nothingAm as
-
-    -- | Generator for 'StallMode'. Shrinks towards 'NoStall'.
-    genStallMode :: H.Gen StallMode
-    genStallMode = Gen.enumBounded
-
-    -- | Generator for 'StallMode'. Shrinks towards 'StallWithNack'.
-    genStallAck :: H.Gen StallAck
-    genStallAck = Gen.enumBounded
-
-    -- | Generator for stall information for 'stallC'. Generates stalls according
-    -- to distribution given in first argument. The second argument indicates how
-    -- many cycles the component is expecting / is producing data for. If the last
-    -- argument is 'NoStall', no stalls will be generated at all.
-    genStalls :: H.Gen Int -> Int -> StallMode -> H.Gen (StallAck, [Int])
-    genStalls genInt n = \case
-      NoStall -> (,[]) <$> genStallAck
-      Stall -> (,) <$> genStallAck <*> Gen.list (Range.singleton n) genInt
-
-
-propWithModelMaybeControlSingleDomain ::
-  forall dom (dataWidth :: C.Nat ) (metaType :: C.Type) .
-  (Test (PacketStream dom dataWidth metaType), C.KnownDomain dom, HasCallStack) =>
-  -- | Options, see 'ExpectOptions'
-  ExpectOptions ->
-  -- | Test data generator
-  H.Gen [PacketStreamM2S dataWidth metaType] ->
-  -- | Model
-  (C.Clock dom -> C.Reset dom -> C.Enable dom -> ([PacketStreamM2S dataWidth metaType] -> [Maybe (PacketStreamM2S dataWidth metaType)])) ->
-  -- | Implementation
-  (C.Clock dom -> C.Reset dom -> C.Enable dom -> Circuit (PacketStream dom dataWidth metaType) (PacketStream dom dataWidth metaType)) ->
-  -- | Property to test for. Function is given the data produced by the model
-  -- as a first argument, and the sampled data as a second argument.
-    ([Maybe (PacketStreamM2S dataWidth metaType)]  -> [Maybe (PacketStreamM2S dataWidth metaType)]  -> H.PropertyT IO ()) ->
-  H.Property
-
-propWithModelMaybeControlSingleDomain eOpts genData model0 circuit0 =
-  propWithModelMaybeControl eOpts genData model1 circuit1
- where
-  clk = C.clockGen
-  rst = resetGen (eoResetCycles eOpts)
-  ena = C.enableGen
-
-  model1 = model0 clk rst ena
-  circuit1 = circuit0 clk rst ena
diff --git a/tests/Test/Cores/Ethernet/MaybeControlProperty.hs b/tests/Test/Cores/Ethernet/MaybeControlProperty.hs
deleted file mode 100644
index 1c43dc0..0000000
--- a/tests/Test/Cores/Ethernet/MaybeControlProperty.hs
+++ /dev/null
@@ -1,68 +0,0 @@
-{-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE RecordWildCards #-}
-
-module Test.Cores.Ethernet.MaybeControlProperty where
-
--- base
-import Prelude
-import Data.Proxy
-import Data.Maybe
-
--- clash-prelude
-import qualified Clash.Prelude as C
-import Clash.Prelude (type (<=))
-
--- hedgehog
-import Hedgehog
-import qualified Hedgehog.Gen as Gen
-import qualified Hedgehog.Range as Range
-
--- tasty
-import Test.Tasty
-import Test.Tasty.Hedgehog (HedgehogTestLimit(HedgehogTestLimit))
-import Test.Tasty.Hedgehog.Extra (testProperty)
-import Test.Tasty.TH (testGroupGenerator)
-
--- clash-protocols
-import Protocols
-import Protocols.Hedgehog
-import qualified Protocols.DfConv as DfConv
-
--- Me
-import Clash.Cores.Ethernet.PacketStream
-import Test.Cores.Ethernet.MaybeControl (propWithModelMaybeControlSingleDomain)
-
-genVec :: (C.KnownNat n, 1 <= n) => Gen a -> Gen (C.Vec n a)
-genVec gen = sequence (C.repeat gen)
-
-prop_MC_packetstream_fifo_id :: Property
-prop_MC_packetstream_fifo_id =
-  propWithModelMaybeControlSingleDomain
-    @C.System
-    defExpectOptions
-    (Gen.list (Range.linear 0 100) genPackets)
-    (C.exposeClockResetEnable model)
-    (C.exposeClockResetEnable @C.System ckt)
-    (\a b -> catMaybes a === catMaybes b)
- where
-  model xs = Just <$> xs
-
-  ckt :: (C.HiddenClockResetEnable dom) =>
-    Circuit
-      (PacketStream dom 1 Int)
-      (PacketStream dom 1 Int)
-  ckt = DfConv.fifo Proxy Proxy (C.SNat @10)
-
-  genPackets =
-    PacketStreamM2S <$>
-    (genVec Gen.enumBounded) <*>
-    (Gen.maybe Gen.enumBounded) <*>
-    Gen.enumBounded <*>
-    Gen.enumBounded
-
-tests :: TestTree
-tests =
-    localOption (mkTimeout 12_000_000 {- 12 seconds -})
-  $ localOption (HedgehogTestLimit (Just 1000))
-  $(testGroupGenerator)
diff --git a/tests/Test/Cores/Ethernet/PacketBuffer.hs b/tests/Test/Cores/Ethernet/PacketBuffer.hs
index 9402d82..06dbd6d 100644
--- a/tests/Test/Cores/Ethernet/PacketBuffer.hs
+++ b/tests/Test/Cores/Ethernet/PacketBuffer.hs
@@ -7,6 +7,7 @@ module Test.Cores.Ethernet.PacketBuffer where
 -- base
 import Prelude
 import Data.Maybe
+import qualified Data.List as L
 
 -- clash-prelude
 import qualified Clash.Prelude as C
@@ -30,7 +31,6 @@ import Protocols.Hedgehog
 -- Me
 import Clash.Cores.Ethernet.PacketStream
 import Clash.Cores.Ethernet.PacketBuffer
-import Test.Cores.Ethernet.MaybeControl (propWithModelMaybeControlSingleDomain)
 import Test.Cores.Ethernet.Util as U
 
 genVec :: (C.KnownNat n, 1 <= n) => Gen a -> Gen (C.Vec n a)
@@ -43,75 +43,51 @@ genPackets =  PacketStreamM2S <$>
               Gen.enumBounded <*>
               Gen.enumBounded
 
-equal :: [Maybe (PacketStreamM2S 4 ())] -> [Maybe (PacketStreamM2S 4 ())] -> Bool
-equal a b = catMaybes a == catMaybes b
+isSubsequenceOf :: Eq a => [a] -> [a] -> Bool
+isSubsequenceOf [] _ = True
+isSubsequenceOf _ [] = False
+isSubsequenceOf (x:xs) (y:ys)
+    | x == y    = isSubsequenceOf xs ys
+    | otherwise = isSubsequenceOf xs (y:ys)
+
+prop_packetBuffer_drop :: Property
+prop_packetBuffer_drop = property $ do
+  let packetBufferSize = d5
+      ckt = exposeClockResetEnable (packetBufferC packetBufferSize) systemClockGen resetGen enableGen
+      gen = U.fullPackets <$> Gen.list (Range.linear 0 100) genPackets
 
-prop_packetBuffer_id :: Property
-prop_packetBuffer_id = property $ do
+  packets :: [PacketStreamM2S 4 ()] <- H.forAll gen
 
-  let ckt = exposeClockResetEnable (packetBufferC d16) systemClockGen resetGen enableGen
+  let packetSize = 2 Prelude.^ snatToNum packetBufferSize
+      cfg = SimulationConfig 1 (2 * packetSize) True
+      cktResult = simulateC ckt cfg (Just <$> packets)
 
-      noGaps :: [Maybe (PacketStreamM2S 4())] -> Bool
-      noGaps (Just (PacketStreamM2S { _last = Nothing }):Nothing:_) = False
-      noGaps (_:xs) = noGaps xs
-      noGaps [] = True
+  let cktByPacket = chunkByPacket $ catMaybes cktResult
+      genByPacket = chunkByPacket packets
+  diff cktByPacket isSubsequenceOf genByPacket
 
-      gen = U.fullPackets <$> Gen.list (Range.linear 0 100) genPackets
-
-  (packets :: [PacketStreamM2S 4 ()]) <- H.forAll gen
- 
-  let packetBufferSize = d16
-      cfg = SimulationConfig 1 (2 * snatToNum packetBufferSize) True
-      sim = simulateC ckt cfg
-
-      circuitResult = sim (Just <$> packets)
-
-  assert $ noGaps circuitResult 
-
--- Fails ~SOMETIMES~ 
--- prop_packetBuffer_dropPackets :: Property
--- prop_packetBuffer_dropPackets = 
---   propWithModelMaybeControlSingleDomain 
---   @C.System
---   defExpectOptions
---   ((Prelude.++) <$>  somePackets <*> ((Prelude.++) <$> bigPacket <*> somePackets) )
---   (C.exposeClockResetEnable model)              -- Desired behaviour of Circuit
---   (C.exposeClockResetEnable ckt)
---   (prop)
---     where
---       somePackets = U.fullPackets <$> Gen.list (Range.linear 0 20) genPackets
---       bigPacket = U.fullPackets <$> lastToNothing <$> Gen.list (Range.linear 151 151) genPackets
-
---       ckt :: forall  (dom :: C.Domain).
---         C.HiddenClockResetEnable dom
---         => Circuit (PacketStream dom 4 ()) (PacketStream dom 4 ())
---       ckt = packetBufferC d7
-
---       model :: [PacketStreamM2S 4 ()] -> [Maybe (PacketStreamM2S 4 ())]
---       model xs = Just <$> (dropLargePackets 7 xs)
-
---       prop modelResult circuitResult = assert $ equal modelResult circuitResult
-
---       lastToNothing :: [PacketStreamM2S 4 ()] -> [PacketStreamM2S 4 ()]
---       lastToNothing list = setLast <$> list
---         where 
---           setLast word = word {_last = Nothing}
-
---       dropLargePackets :: Int -> [PacketStreamM2S 4 ()] -> [PacketStreamM2S 4 ()]
---       dropLargePackets size wordlist = Prelude.concat $ Prelude.reverse $ Prelude.filter fitts $ splitOnLast wordlist [] []
---         where 
---           splitOnLast :: [PacketStreamM2S 4 ()] -> [PacketStreamM2S 4 ()] -> [[PacketStreamM2S 4 ()]] -> [[PacketStreamM2S 4 ()]]
---           splitOnLast (x:xs) packet list = case (x:xs) of 
---             (PacketStreamM2S { _last = Nothing } : bs ) -> splitOnLast bs (x : packet) list
---             (PacketStreamM2S { _last = Just _ }  : bs ) -> splitOnLast bs [] ((Prelude.reverse (x : packet)) : list)
---           splitOnLast [] [] list = list 
---           splitOnLast [] packet list = (Prelude.reverse packet) : list
-
---           fitts :: [PacketStreamM2S 4 ()] -> Bool
---           fitts l = (Prelude.length l) <=  (2 Prelude.^ size) 
+prop_packetBuffer_id :: Property
+prop_packetBuffer_id =
+  propWithModelSingleDomain
+    @C.System
+    defExpectOptions
+    (U.fullPackets <$> Gen.list (Range.linear 0 100) genPackets)
+    (C.exposeClockResetEnable id)
+    (C.exposeClockResetEnable ckt)
+    (===)
+ where
+  ckt :: HiddenClockResetEnable System => Circuit (PacketStream System 4 ()) (PacketStream System 4 ())
+  ckt = packetBufferC d12
+
+  genPackets =
+    PacketStreamM2S <$>
+    (genVec Gen.enumBounded) <*>
+    (Gen.maybe Gen.enumBounded) <*>
+    Gen.enumBounded <*>
+    Gen.enumBounded
 
 tests :: TestTree
 tests =
     localOption (mkTimeout 30_000_000 {- 30 seconds -})
-  $ localOption (HedgehogTestLimit (Just 1000))
+  $ localOption (HedgehogTestLimit (Just 10000))
   $(testGroupGenerator)
diff --git a/tests/unittests.hs b/tests/unittests.hs
index d9e85a4..835e2aa 100644
--- a/tests/unittests.hs
+++ b/tests/unittests.hs
@@ -7,8 +7,6 @@ import qualified Test.Lattice.ECP5.UART
 import qualified Test.Cores.Ethernet.UpConverter
 import qualified Test.Cores.Ethernet.DownConverter
 import qualified Test.Cores.Ethernet.PacketBuffer
-import qualified Test.Cores.Ethernet.MaybeControl
-import qualified Test.Cores.Ethernet.MaybeControlProperty
 import qualified Test.Cores.Ethernet.InterpacketGapInserter
 import qualified Test.Cores.Ethernet.AsyncFIFO
 
@@ -16,9 +14,9 @@ main :: IO ()
 main = defaultMain $ testGroup "."
   [ Test.Cores.Ethernet.PacketStream.tests
     , Test.Lattice.ECP5.UART.tests
+    , Test.Cores.Ethernet.AsyncFIFO.tests
     , Test.Cores.Ethernet.UpConverter.tests
     , Test.Cores.Ethernet.DownConverter.tests
-    , Test.Cores.Ethernet.MaybeControlProperty.tests
     , Test.Cores.Ethernet.PacketBuffer.tests
     , Test.Cores.Ethernet.InterpacketGapInserter.tests
   ]

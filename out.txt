Build profile: -w ghc-9.6.5 -O1
In order, the following will be built (use -v for more details):
 - clash-eth-0.1 (lib:clash-eth, exe:clash, exe:clashi, test:doctests, test:test-library) (first run)
Preprocessing library for clash-eth-0.1..
Building library for clash-eth-0.1..
[21 of 34] Compiling Protocols.Extra.PacketStream.Packetizers ( src/Protocols/Extra/PacketStream/Packetizers.hs, /home/rowan.goemans/Documents/engineering/school/qbaylogic-clash-based-macipudp-stack-spring24/dist-newstyle/build/aarch64-linux/ghc-9.6.5/clash-eth-0.1/build/Protocols/Extra/PacketStream/Packetizers.o, /home/rowan.goemans/Documents/engineering/school/qbaylogic-clash-based-macipudp-stack-spring24/dist-newstyle/build/aarch64-linux/ghc-9.6.5/clash-eth-0.1/build/Protocols/Extra/PacketStream/Packetizers.dyn_o ) [Source file changed]
tcPluginInit ghc-typelits-extra
tcPluginInit ghc-typelits-natnormalise
tcPluginInit ghc-typelits-knownnat
checkFamInstConsistency
  [Data.Maybe, Clash.Sized.Vector.Extra, Data.Maybe.Extra,
   Protocols.Extra.PacketStream, Clash.Prelude, Protocols,
   Protocols.Df, Data.Constraint.Deferrable]
Tc2 (src)
Tc3
tcExtendKindEnvList []
tcExtendKindEnvList []
tcDeriving []
rnd
Adding instances:
Tc3b
Tc3c
tcSemigroupWarnings
tcPreludeClashWarn/wouldBeImported
tcMissingParentClassWarn
tcMissingParentClassWarn/isInsts []
Tc4
Tc4a
Tc5
tcExtendKindEnvList []
tcHsSigType { forall (a_a99M :: Nat). a_a99M <= 0 => ()
pushLevelAndSolveEqualitiesX { Called from tc_lhs_sig_type
newAnonMetaTyVar t_a99U[tau:1]
pushLevelAndCaptureConstraints { 2
bindExplicitTKBndrs [(a_a99M :: Nat)]
solveEqualities { Called from tcLHsKindSig
lk1 Nat
tcInferTyApps {
  Nat
  []
tcInferTyApps } Nat :: Type
checkExpectedKind
  Nat
  Type
checkExpectedKindX
  Nat
  act_kind': Type
  exp_kind: Type
newNoTcEvBinds unique = a9ax
solveWanteds {
  Level = 2
  WC {}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc = WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
resetUnificationFlag
  ambient: 2
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
zonkSimples done: {}
emitFlatConstraints { WC {}
emitFlatConstraints }
  simples: {}
  errs:    {}
emitDelayedErrors {}
solveEqualities }
tcLHsKindSig
  Nat
  Nat
kindGeneralizeNone Nat
checkValidType Nat :: Type
done ct Nat
Ambiguity check for Nat
tc_sub_type (general case)
  ty_actual   = Nat
  ty_expected = Nat
u_tys
  tclvl 2
  Nat ~ Nat
  arising from a type equality Nat ~ Nat
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Nat
  wanted =  WC {}
newTcEvBinds unique = a9ay
solveWanteds {
  Level = 2
  WC {}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc = WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
resetUnificationFlag
  ambient: 2
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for Nat
checkValidType done Nat :: Type
tcLHsKindSig2 Nat
tc_extend_local_env
  [(a_a99M, Type variable ‘a_a99M’ = a_a99M[sk:2] :: Nat)]
tcExtendBinderStack [a_a99M a_a99M[sk:2]]
lk1 <=
tcInferTyApps {
  (<=)
  [HsValArg a_a99M, HsValArg 0]
tcInferTyApps (need to instantiate)
  {t_i6uh}
  <InScope = {}
   IdSubst   = []
   TvSubst   = []
   CvSubst   = []>
cloneAnonMetaTyVar t_a9az[tau:2] :: Type
tcInferTyApps (vis normal app)
  [->] t_i6uh
  a_a99M
  t_i6uh
  <InScope = {t_a9az[tau:2]}
   IdSubst   = []
   TvSubst   = [i6uh :-> t_a9az[tau:2]]
   CvSubst   = []>
lk1 a_a99M
tcInferTyApps {
  a_a99M
  []
tcInferTyApps } a_a99M[sk:2] :: Nat
checkExpectedKind
  a_a99M[sk:2]
  Nat
checkExpectedKindX
  a_a99M
  act_kind': Nat
  exp_kind: t_a9az[tau:2]
u_tys
  tclvl 2
  Nat ~ t_a9az[tau:2]
  arising from a type equality Nat ~ t_a9az[tau:2]
u_tys
  tclvl 2
  Type ~ Type
  arising from a kind equality arising from t_a9az[tau:2] ~ Nat
u_tys yields no coercion
uUnfilledVar2 ok
  t_a9az[tau:2] :: Type
  Nat :: Type
  True
  <Type>_N
writeMetaTyVar t_a9az[tau:2] :: Type := Nat
u_tys yields no coercion
checkExpectedKind
  Nat
  t_a9az[tau:2]
  <Nat>_N
tcInferTyApps (vis normal app) 2 t_a9az[tau:2]
tcInferTyApps (vis normal app)
  [->] t_i6uh
  0
  t_i6uh
  <InScope = {t_a9az[tau:2]}
   IdSubst   = []
   TvSubst   = [i6uh :-> t_a9az[tau:2]]
   CvSubst   = []>
checkExpectedKind
  0
  Natural
checkExpectedKindX
  0
  act_kind': Natural
  exp_kind: t_a9az[tau:2]
u_tys
  tclvl 2
  Natural ~ t_a9az[tau:2]
  arising from a type equality Natural ~ t_a9az[tau:2]
found filled tyvar t_a9az[tau:2] :-> Nat
u_tys yields no coercion
checkExpectedKind
  Natural
  t_a9az[tau:2]
  <Natural>_N
tcInferTyApps (vis normal app) 2 t_a9az[tau:2]
tcInferTyApps } a_a99M[sk:2] <= 0 :: Constraint
checkExpectedKind
  a_a99M[sk:2] <= 0
  Constraint
checkExpectedKindX
  a_a99M <= 0
  act_kind': Constraint
  exp_kind: Constraint
newAnonMetaTyVar t_a9aI[tau:2]
tc_hs_type tuple 2 []
finish_tuple
  BoxedTuple
  []
  TYPE t_a9aI[tau:2]
checkExpectedKind
  ()
  Type
checkExpectedKindX
  ()
  act_kind': Type
  exp_kind: TYPE t_a9aI[tau:2]
u_tys
  tclvl 2
  Type ~ TYPE t_a9aI[tau:2]
  arising from a type equality Type ~ TYPE t_a9aI[tau:2]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.LiftedRep ~ t_a9aI[tau:2]
  arising from a type equality Type ~ TYPE t_a9aI[tau:2]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.RuntimeRep ~ ghc-prim:GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a9aI[tau:2] ~ ghc-prim:GHC.Types.LiftedRep
u_tys yields no coercion
uUnfilledVar2 ok
  t_a9aI[tau:2] :: ghc-prim:GHC.Types.RuntimeRep
  ghc-prim:GHC.Types.LiftedRep :: ghc-prim:GHC.Types.RuntimeRep
  True
  <ghc-prim:GHC.Types.RuntimeRep>_N
writeMetaTyVar
  t_a9aI[tau:2] :: ghc-prim:GHC.Types.RuntimeRep := ghc-prim:GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  Type
  TYPE t_a9aI[tau:2]
  <Type>_N
checkExpectedKind
  (a_a99M[sk:2] <= 0) => ()
  Type
checkExpectedKindX
  ()
  act_kind': Type
  exp_kind: TYPE t_a99U[tau:1]
u_tys
  tclvl 2
  Type ~ TYPE t_a99U[tau:1]
  arising from a type equality Type ~ TYPE t_a99U[tau:1]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.LiftedRep ~ t_a99U[tau:1]
  arising from a type equality Type ~ TYPE t_a99U[tau:1]
uUnfilledVar2 not ok
  t_a99U[tau:1]
  ghc-prim:GHC.Types.LiftedRep
New coercion hole:
  co_a9h4 :: ghc-prim:GHC.Types.LiftedRep
             ghc-prim:GHC.Prim.~# t_a99U[tau:1]
utype_defer
  ghc-prim:GHC.Types.LiftedRep
  t_a99U[tau:1]
  arising from a type equality Type ~ TYPE t_a99U[tau:1]
  In the type signature:
    foo :: forall (a_a99M :: Nat). a_a99M <= 0 => ()
utype_defer2 {co_a9h4}
u_tys yields coercion: {co_a9h4}
u_tys yields coercion: (TYPE {co_a9h4})_N
checkExpectedKind
  Type
  TYPE t_a99U[tau:1]
  (TYPE {co_a9h4})_N
pushLevelAndCaptureConstraints } 2
newNoTcEvBinds unique = a9h6
newNoTcEvBinds unique = a9h7
solveWanteds {
  Level = 1
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                          ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                          ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 2
    Skolems = (a_a99M[sk:2] :: Nat)
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                    ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
    Binds = CoEvBindsVar<a9h6>
    an explicit forall (a_a99M :: Nat) }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveWanteds {
  Level = 2
  WC {wc_simple =
        [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
solveSimpleWanteds {
  {[W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                           ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 2
  work item = [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                      ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                                        ghc-prim:GHC.Prim.~# t_a99U[tau:1] (CNonCanonical)
canEvNC:eq
  ghc-prim:GHC.Types.LiftedRep
  t_a99U[tau:1]
can_eq_nc
  False
  [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                          ghc-prim:GHC.Prim.~# t_a99U[tau:1]
  nominal equality
  ghc-prim:GHC.Types.LiftedRep
  ghc-prim:GHC.Types.LiftedRep
  t_a99U[tau:1]
  t_a99U[tau:1]
rewrite { ghc-prim:GHC.Types.LiftedRep
rewrite } ghc-prim:GHC.Types.LiftedRep
rewrite { t_a99U[tau:1]
Unfilled tyvar (t_a99U[tau:1] :: ghc-prim:GHC.Types.RuntimeRep)
rewrite } t_a99U[tau:1]
New coercion hole:
  co_a9h8 :: t_a99U[tau:1]
             ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
Emitting new coercion hole
  {co_a9h8} :: t_a99U[tau:1]
               ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
Filling coercion hole co_a9h4 := Sym {co_a9h8}
rewriteEqEvidence
  [W] hole{co_a9h4} {0}:: ghc-prim:GHC.Types.LiftedRep
                          ghc-prim:GHC.Prim.~# t_a99U[tau:1]
  t_a99U[tau:1]
  ghc-prim:GHC.Types.LiftedRep
  Sym {co_a9h8}
  {}
CEqCan
  t_a99U[tau:1]
  ghc-prim:GHC.Types.LiftedRep
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] hole{co_a9h8} {0}:: t_a99U[tau:1]
                                        ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep (CEqCan)
tryToSolveByUnification
  t_a99U[tau:1] ~ ghc-prim:GHC.Types.LiftedRep
  TouchableOuterLevel(1 [])
Sneaky unification:
  Unifies: t_a99U[tau:1] := ghc-prim:GHC.Types.LiftedRep
  Coercion: t_a99U[tau:1] ~ ghc-prim:GHC.Types.LiftedRep
  Left Kind is: ghc-prim:GHC.Types.RuntimeRep
  Right Kind is: ghc-prim:GHC.Types.RuntimeRep
unifyTyVar t_a99U[tau:1] := ghc-prim:GHC.Types.LiftedRep
writeMetaTyVar
  t_a99U[tau:1] :: ghc-prim:GHC.Types.RuntimeRep := ghc-prim:GHC.Types.LiftedRep
Filling coercion hole co_a9h8 := <ghc-prim:GHC.Types.LiftedRep>_N
end stage interact with inerts }
Step 1[l:2,d:0] Solved by unification:
    [W] hole{co_a9h8} {0}:: t_a99U[tau:1]
                            ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
resetUnificationFlag
  ambient: 2
  unif_lvl: Just 1
unif_happened False
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getHasGivenEqs
  given_eqs: False
  ge_lvl: 0
  ambient level: 2
  Inerts: {Innermost given equalities = 0
           Given eqs at this level = False}
  Insols: {}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 2
    Skolems = (a_a99M[sk:2] :: Nat)
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = CoEvBindsVar<a9h6>
    an explicit forall (a_a99M :: Nat) }
neededEvVars
  old_needs: {}
  seeds3: {co_a9h8}
  tcvs: {co_a9h8}
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 2
                Skolems = (a_a99M[sk:2] :: Nat)
                Given-eqs = NoGivenEqs
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = CoEvBindsVar<a9h6>
                an explicit forall (a_a99M :: Nat) }
solveImplication end }
  has_given_eqs = NoGivenEqs
  res_implic = Just Implic {
                      TcLevel = 2
                      Skolems = (a_a99M[sk:2] :: Nat)
                      Given-eqs = NoGivenEqs
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = CoEvBindsVar<a9h6>
                      an explicit forall (a_a99M :: Nat) }
  implication evbinds = {}
  implication tvcs = {co_a9h8}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99M[sk:2] :: Nat)
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9h6>
                             an explicit forall (a_a99M :: Nat) }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Just 1
unif_happened True
simplify_loop iteration=1 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99M[sk:2] :: Nat)
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9h6>
                             an explicit forall (a_a99M :: Nat) }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 2
                     Skolems = (a_a99M[sk:2] :: Nat)
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9h6>
                     an explicit forall (a_a99M :: Nat) }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99M[sk:2] :: Nat)
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9h6>
                    an explicit forall (a_a99M :: Nat) }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
Constraint solver steps = 1
pushLevelAndSolveEqualities }
  Residual: WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99M[sk:2] :: Nat)
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9h6>
                    an explicit forall (a_a99M :: Nat) }}
  Level: 1
doNotQuantifyTyVars has nothing to error on
tc_lhs_sig_type
  HsOuterExplicit: [(a_a99M :: Nat)]
  HsOuterExplicit: [(a_a99M :: Nat)]
quantifyTyVars has nothing to quantify
newNoTcEvBinds unique = a9hB
tcHsSigType 2
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99M[sk:2] :: Nat)
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9h6>
              an explicit forall (a_a99M :: Nat) }}
    Binds = CoEvBindsVar<a9hB>
    the type signature for ‘foo’ }
newNoTcEvBinds unique = a9hC
solveWanteds {
  Level = 0
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99M[sk:2] :: Nat)
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9h6>
                    an explicit forall (a_a99M :: Nat) }}
          Binds = CoEvBindsVar<a9hB>
          the type signature for ‘foo’ }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99M[sk:2] :: Nat)
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9h6>
                    an explicit forall (a_a99M :: Nat) }}
          Binds = CoEvBindsVar<a9hB>
          the type signature for ‘foo’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99M[sk:2] :: Nat)
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9h6>
              an explicit forall (a_a99M :: Nat) }}
    Binds = CoEvBindsVar<a9hB>
    the type signature for ‘foo’ }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveWanteds {
  Level = 1
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99M[sk:2] :: Nat)
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9h6>
                             an explicit forall (a_a99M :: Nat) }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 2
                     Skolems = (a_a99M[sk:2] :: Nat)
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9h6>
                     an explicit forall (a_a99M :: Nat) }}
  current evbinds  = {}
getHasGivenEqs
  given_eqs: False
  ge_lvl: 0
  ambient level: 1
  Inerts: {Innermost given equalities = 0
           Given eqs at this level = False}
  Insols: {}
solveImplication 2
  {}
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99M[sk:2] :: Nat)
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9h6>
          an explicit forall (a_a99M :: Nat) }}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99M[sk:2] :: Nat)
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9h6>
              an explicit forall (a_a99M :: Nat) }}
    Binds = CoEvBindsVar<a9hB>
    the type signature for ‘foo’ }
neededEvVars
  old_needs: {}
  seeds3: {co_a9h8}
  tcvs: {}
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems =
                Given-eqs = NoGivenEqs
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = CoEvBindsVar<a9hB>
                the type signature for ‘foo’ }
solveImplication end }
  has_given_eqs = NoGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems =
                      Given-eqs = NoGivenEqs
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = CoEvBindsVar<a9hB>
                      the type signature for ‘foo’ }
  implication evbinds = {}
  implication tvcs = {}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems =
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9hB>
                             the type signature for ‘foo’ }}
resetUnificationFlag
  ambient: 0
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems =
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9hB>
                     the type signature for ‘foo’ }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
emitFlatConstraints {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9hB>
          the type signature for ‘foo’ }}
emitFlatConstraints }
  simples: {}
  errs:    {}
emitDelayedErrors {}
checkValidType forall (a :: Nat). (a <= 0) => () :: Type
check_type
  forall (a :: Nat). (a <= 0) => ()
  ArbitraryRank
check_valid_theta [a_a99M[sk:2] <= 0]
done ct forall (a :: Nat). (a <= 0) => ()
Ambiguity check for forall (a :: Nat). (a <= 0) => ()
tc_sub_type (general case)
  ty_actual   = forall (a :: Nat). (a <= 0) => ()
  ty_expected = forall (a :: Nat). (a <= 0) => ()
pushLevelAndCaptureConstraints { 1
cloneAnonMetaTyVar a_a9hQ[tau:1] :: Nat
instCallConstraints [irred_a9hR]
Instantiating
  origin arising from a type ambiguity check for
         the type signature for ‘foo’
  tvs [a_a99M[sk:2]]
  theta [a_a99M[sk:2] <= 0]
  type ()
  with a_a9hQ[tau:1]
  theta: [a_a9hQ[tau:1] <= 0]
u_tys
  tclvl 1
  () ~ ()
  arising from a type equality () ~ ()
u_tys yields no coercion
pushLevelAndCaptureConstraints } 1
newTcEvBinds unique = a9hS
checkConstraints
  1
  [a_a9hN[sk:1]]
simplifyAmbiguityCheck {
  type =  forall (a :: Nat). (a <= 0) => ()
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9hN[sk:1] :: Nat)
                    Given-eqs = MaybeGivenEqs
                    Status = Unsolved
                    Given = irred_a9hO :: a_a9hN[sk:1] <= 0
                    Wanted =
                      WC {wc_simple =
                            [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
                    Binds = EvBindsVar<a9hS>
                    the type signature for:
                      foo :: forall (a :: Nat). (a <= 0) => () }}
newTcEvBinds unique = a9hT
solveWanteds {
  Level = 0
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9hN[sk:1] :: Nat)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9hO :: a_a9hN[sk:1] <= 0
          Wanted =
            WC {wc_simple =
                  [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
          Binds = EvBindsVar<a9hS>
          the type signature for:
            foo :: forall (a :: Nat). (a <= 0) => () }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9hN[sk:1] :: Nat)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9hO :: a_a9hN[sk:1] <= 0
          Wanted =
            WC {wc_simple =
                  [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
          Binds = EvBindsVar<a9hS>
          the type signature for:
            foo :: forall (a :: Nat). (a <= 0) => () }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (a_a9hN[sk:1] :: Nat)
    Given-eqs = MaybeGivenEqs
    Status = Unsolved
    Given = irred_a9hO :: a_a9hN[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
    Binds = EvBindsVar<a9hS>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveSimpleGivens {
  [[G] irred_a9hO {0}:: a_a9hN[sk:1] <= 0 (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] irred_a9hO {0}:: a_a9hN[sk:1] <= 0 (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] irred_a9hO {0}:: a_a9hN[sk:1]
                                     <= 0 (CNonCanonical)
canEvNC:irred a_a9hN[sk:1] <= 0
can_pred IrredPred =  a_a9hN[sk:1] <= 0
rewrite { a_a9hN[sk:1] <= 0
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9hN[sk:1] <=? 0) (Data.Type.Ord.LeErrMsg a_a9hN[sk:1] 0)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9hN[sk:1] 0) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9hN[sk:1] 0
  Match succeeded:
    Rewrites to: CmpNat a_a9hN[sk:1] 0
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9hN[sk:1]>_N <0>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Nat, a_a9hN[sk:1], 0]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9hN[sk:1] 0
    reductionReducedType: CmpNat a_a9hN[sk:1] 0
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9hN[sk:1]>_N <0>_N}
matchFamTcM
  Matching: CmpNat a_a9hN[sk:1] 0
  Match failed
Unfilled tyvar (a_a9hN[sk:1] :: Nat)
matchFamTcM
  Matching: CmpNat a_a9hN[sk:1] 0
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9hN[sk:1] 0) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9hN[sk:1] :: Nat)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
    (TypeError ...)
addTcEvBind
  a9hS
  [G] irred_a9ig
    = irred_a9hO
      `cast` ((GHC.TypeError.Assert
                 (Data.Type.Ord.OrdCond
                    <Bool>_N
                    (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9hN[sk:1]>_N <0>_N)
                    <True>_N
                    <True>_N
                    <False>_N)_N
                 <(TypeError ...)>_N)_R
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond
                      (Data.Type.Ord.Compare a_a9hN[sk:1] 0) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hN[sk:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hN[sk:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [G] irred_a9ig {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                         (TypeError ...) (CIrredCan(irred))
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9hN[sk:1] 0)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 1[l:1,d:0] Kept as inert:
    [G] irred_a9ig {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9hN[sk:1] 0) True True False)
                                      (TypeError ...) (CIrredCan(irred))
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
End solveSimpleGivens }
solveWanteds {
  Level = 1
  WC {wc_simple =
        [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
solveSimpleWanteds {
  {[W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [W] irred_a9hR {0}:: a_a9hQ[tau:1] <= 0 (CNonCanonical)
  inerts = {Irreds = [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9hN[sk:1] 0) True True False)
                                            (TypeError ...) (CIrredCan(irred))
            Innermost given equalities = 0
            Given eqs at this level = True}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] irred_a9hR {0}:: a_a9hQ[tau:1]
                                     <= 0 (CNonCanonical)
canEvNC:irred a_a9hQ[tau:1] <= 0
can_pred IrredPred =  a_a9hQ[tau:1] <= 0
rewrite { a_a9hQ[tau:1] <= 0
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9hQ[tau:1] <=? 0) (Data.Type.Ord.LeErrMsg a_a9hQ[tau:1] 0)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9hQ[tau:1] 0) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9hQ[tau:1] 0
  Match succeeded:
    Rewrites to: CmpNat a_a9hQ[tau:1] 0
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9hQ[tau:1]>_N <0>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Nat, a_a9hQ[tau:1], 0]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9hQ[tau:1] 0
    reductionReducedType: CmpNat a_a9hQ[tau:1] 0
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9hQ[tau:1]>_N <0>_N}
matchFamTcM
  Matching: CmpNat a_a9hQ[tau:1] 0
  Match failed
Unfilled tyvar (a_a9hQ[tau:1] :: Nat)
matchFamTcM
  Matching: CmpNat a_a9hQ[tau:1] 0
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9hQ[tau:1] 0) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9hQ[tau:1] :: Nat)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
    (TypeError ...)
Emitting new wanted
  irred_a9ih :: GHC.TypeError.Assert
                  (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                  (TypeError ...)
  arising from a type ambiguity check for
  the type signature for ‘foo’
  at src/Protocols/Extra/PacketStream/Packetizers.hs:473:8-38
addTcEvBind
  a9hS
  [W] irred_a9hR
    = irred_a9ih
      `cast` (Sub (Sym (GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             <Bool>_N
                             (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9hQ[tau:1]>_N <0>_N)
                             <True>_N
                             <True>_N
                             <False>_N)_N
                          <(TypeError ...)>_N)_N)
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond
                          (Data.Type.Ord.Compare a_a9hQ[tau:1] 0) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hQ[tau:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hQ[tau:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [W] irred_a9ih {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                         (TypeError ...) (CIrredCan(irred))
No local instance for
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
    (TypeError ...)
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9hQ[tau:1] 0)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 2[l:1,d:0] Kept as inert:
    [W] irred_a9ih {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9hQ[tau:1] 0) True True False)
                                      (TypeError ...) (CIrredCan(irred))
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[W] irred_a9ih {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
  implics = {}
zonkSimples done:
  {[W] irred_a9ih {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                          (TypeError ...) (CIrredCan(irred))}
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9ih {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyExtra
  [NatInequality
   a_a9hN[sk:1]
   0
   True
   Untouched,
   NatInequality
   a_a9hQ[tau:1]
   0
   True
   Untouched]
unifyExtra leq result (a_a9hN[sk:1], 0, True)
unifyExtra leq result (a_a9hQ[tau:1], 0, True)
normalised
  Simplified
  Solved:
  []
  New:
  []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9ih {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyNats
  [(Right ([G] irred_a9ig {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (a_a9hN[sk:1], 0, True)),
    []),
   (Right ([W] irred_a9ih {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (a_a9hQ[tau:1], 0, True)),
    [])]
unifyNats(ineq) results
  ([G] irred_a9ig {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   (a_a9hN[sk:1], 0, True),
   -1 * a_a9hN[sk:1],
   [(a_a9hN[sk:1], 0, True)])
normalised
  Impossible Right ([G] irred_a9ig {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9hN[sk:1] 0) True True False)
                                           (TypeError ...) (CIrredCan(irred)),
                    (a_a9hN[sk:1], 0, True))
tcPluginSolve contradiction ghc-typelits-natnormalise
  bad = [[G] irred_a9ig {0}:: GHC.TypeError.Assert
                                (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                (TypeError ...) (CIrredCan(irred))]
tcPluginSolve start ghc-typelits-knownnat
  given   = []
  wanted  = [[W] irred_a9ih {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9hQ[tau:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))
                   [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9hN[sk:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_simple =
                   [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9hQ[tau:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))
                   [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9hN[sk:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
  current evbinds  = {[G] irred_a9ig
                        = irred_a9hO
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9hN[sk:1]>_N <0>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9hN[sk:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9hN[sk:1] 0) True True False)
                                           (TypeError ...)),
                      [W] irred_a9hR
                        = irred_a9ih
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9hQ[tau:1]>_N <0>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hQ[tau:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare a_a9hQ[tau:1] 0)
                                              True
                                              True
                                              False)
                                           (TypeError ...))}
getHasGivenEqs
  given_eqs: True
  ge_lvl: 0
  ambient level: 1
  Inerts: {Irreds = [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9hN[sk:1] 0) True True False)
                                           (TypeError ...) (CIrredCan(irred))
           Innermost given equalities = 0
           Given eqs at this level = True}
  Insols: {}
solveImplication 2
  {}
  WC {wc_simple =
        [W] irred_a9ih {0}:: GHC.TypeError.Assert
                               (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                               (TypeError ...) (CIrredCan(irred))
        [G] irred_a9ig {0}:: GHC.TypeError.Assert
                               (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                               (TypeError ...) (CIrredCan(irred))}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9hN[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9hO :: a_a9hN[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9hS>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
neededEvVars
  old_needs: {}
  seeds3: {irred_a9ih}
  tcvs: {}
  ev_binds: [a9ig :-> [G] irred_a9ig
                        = irred_a9hO
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9hN[sk:1]>_N <0>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9hN[sk:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9hN[sk:1] 0) True True False)
                                           (TypeError ...)),
             a9hR :-> [W] irred_a9hR
                        = irred_a9ih
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9hQ[tau:1]>_N <0>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9hQ[tau:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare a_a9hQ[tau:1] 0)
                                              True
                                              True
                                              False)
                                           (TypeError ...))]
  live_ev_binds: [a9hR :-> [W] irred_a9hR
                             = irred_a9ih
                               `cast` (Sub (Sym (GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      <Bool>_N
                                                      (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                           <a_a9hQ[tau:1]>_N <0>_N)
                                                      <True>_N
                                                      <True>_N
                                                      <False>_N)_N
                                                   <(TypeError ...)>_N)_N)
                                       :: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9hQ[tau:1] 0) True True False)
                                            (TypeError ...)
                                          ~R# GHC.TypeError.Assert
                                                (Data.Type.Ord.OrdCond
                                                   (Data.Type.Ord.Compare a_a9hQ[tau:1] 0)
                                                   True
                                                   True
                                                   False)
                                                (TypeError ...))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = (a_a9hN[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9hO :: a_a9hN[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9hQ[tau:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9hN[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9hS>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
solveImplication end }
  has_given_eqs = LocalGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (a_a9hN[sk:1] :: Nat)
                      Given-eqs = LocalGivenEqs
                      Status = Unsolved
                      Given = irred_a9hO :: a_a9hN[sk:1] <= 0
                      Wanted =
                        WC {wc_simple =
                              [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                                     (Data.Type.Ord.OrdCond
                                                        (CmpNat a_a9hQ[tau:1] 0) True True False)
                                                     (TypeError ...) (CIrredCan(irred))
                              [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                                     (Data.Type.Ord.OrdCond
                                                        (CmpNat a_a9hN[sk:1] 0) True True False)
                                                     (TypeError ...) (CIrredCan(irred))}
                      Binds = EvBindsVar<a9hS>
                      the type signature for:
                        foo :: forall (a :: Nat). (a <= 0) => () }
  implication evbinds = {[W] irred_a9hR
                           = irred_a9ih
                             `cast` (Sub (Sym (GHC.TypeError.Assert
                                                 (Data.Type.Ord.OrdCond
                                                    <Bool>_N
                                                    (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                         <a_a9hQ[tau:1]>_N <0>_N)
                                                    <True>_N
                                                    <True>_N
                                                    <False>_N)_N
                                                 <(TypeError ...)>_N)_N)
                                     :: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9hQ[tau:1] 0) True True False)
                                          (TypeError ...)
                                        ~R# GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 (Data.Type.Ord.Compare a_a9hQ[tau:1] 0)
                                                 True
                                                 True
                                                 False)
                                              (TypeError ...))}
  implication tvcs = {}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_a9hN[sk:1] :: Nat)
                             Given-eqs = LocalGivenEqs
                             Status = Unsolved
                             Given = irred_a9hO :: a_a9hN[sk:1] <= 0
                             Wanted =
                               WC {wc_simple =
                                     [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                                            (Data.Type.Ord.OrdCond
                                                               (CmpNat a_a9hQ[tau:1] 0)
                                                               True
                                                               True
                                                               False)
                                                            (TypeError ...) (CIrredCan(irred))
                                     [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                                            (Data.Type.Ord.OrdCond
                                                               (CmpNat a_a9hN[sk:1] 0)
                                                               True
                                                               True
                                                               False)
                                                            (TypeError ...) (CIrredCan(irred))}
                             Binds = EvBindsVar<a9hS>
                             the type signature for:
                               foo :: forall (a :: Nat). (a <= 0) => () }}
resetUnificationFlag
  ambient: 0
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (a_a9hN[sk:1] :: Nat)
                     Given-eqs = LocalGivenEqs
                     Status = Unsolved
                     Given = irred_a9hO :: a_a9hN[sk:1] <= 0
                     Wanted =
                       WC {wc_simple =
                             [W] irred_a9ih {0}:: GHC.TypeError.Assert
                                                    (Data.Type.Ord.OrdCond
                                                       (CmpNat a_a9hQ[tau:1] 0) True True False)
                                                    (TypeError ...) (CIrredCan(irred))
                             [G] irred_a9ig {0}:: GHC.TypeError.Assert
                                                    (Data.Type.Ord.OrdCond
                                                       (CmpNat a_a9hN[sk:1] 0) True True False)
                                                    (TypeError ...) (CIrredCan(irred))}
                     Binds = EvBindsVar<a9hS>
                     the type signature for:
                       foo :: forall (a :: Nat). (a <= 0) => () }}
  current evbinds  = {}
Constraint solver steps = 2
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall (a :: Nat). (a <= 0) => ()
checkValidType done forall (a :: Nat). (a <= 0) => () :: Type
end tcHsSigType } forall (a :: Nat). (a <= 0) => ()
tcuser forall (a :: Nat). (a <= 0) => ()
tcHsSigType { a_a99N <= 1 => ()
pushLevelAndSolveEqualitiesX { Called from tc_lhs_sig_type
newAnonMetaTyVar t_a9ij[tau:1]
pushLevelAndCaptureConstraints { 2
newMetaKindVar k_a9ik[tau:2]
bindImplicitTKBndrsX
  [a_a99N]
  [a_a99N[sk:2]]
tc_extend_local_env
  [(a_a99N, Type variable ‘a_a99N’ = a_a99N[sk:2] :: k_a9ik[tau:2])]
tcExtendBinderStack [a_a99N a_a99N[sk:2]]
lk1 <=
tcInferTyApps {
  (<=)
  [HsValArg a_a99N, HsValArg 1]
tcInferTyApps (need to instantiate)
  {t_i6uh}
  <InScope = {}
   IdSubst   = []
   TvSubst   = []
   CvSubst   = []>
cloneAnonMetaTyVar t_a9il[tau:2] :: Type
tcInferTyApps (vis normal app)
  [->] t_i6uh
  a_a99N
  t_i6uh
  <InScope = {t_a9il[tau:2]}
   IdSubst   = []
   TvSubst   = [i6uh :-> t_a9il[tau:2]]
   CvSubst   = []>
lk1 a_a99N
tcInferTyApps {
  a_a99N
  []
tcInferTyApps } a_a99N[sk:2] :: k_a9ik[tau:2]
checkExpectedKind
  a_a99N[sk:2]
  k_a9ik[tau:2]
checkExpectedKindX
  a_a99N
  act_kind': k_a9ik[tau:2]
  exp_kind: t_a9il[tau:2]
u_tys
  tclvl 2
  k_a9ik[tau:2] ~ t_a9il[tau:2]
  arising from a type equality k_a9ik[tau:2] ~ t_a9il[tau:2]
u_tys
  tclvl 2
  Type ~ Type
  arising from a kind equality arising from
    k_a9ik[tau:2] ~ t_a9il[tau:2]
u_tys yields no coercion
uUnfilledVar2 ok
  k_a9ik[tau:2] :: Type
  t_a9il[tau:2] :: Type
  True
  <Type>_N
writeMetaTyVar k_a9ik[tau:2] :: Type := t_a9il[tau:2]
u_tys yields no coercion
checkExpectedKind
  k_a9ik[tau:2]
  t_a9il[tau:2]
  <t_a9il[tau:2]>_N
tcInferTyApps (vis normal app) 2 t_a9il[tau:2]
tcInferTyApps (vis normal app)
  [->] t_i6uh
  1
  t_i6uh
  <InScope = {t_a9il[tau:2]}
   IdSubst   = []
   TvSubst   = [i6uh :-> t_a9il[tau:2]]
   CvSubst   = []>
checkExpectedKind
  1
  Natural
checkExpectedKindX
  1
  act_kind': Natural
  exp_kind: t_a9il[tau:2]
u_tys
  tclvl 2
  Natural ~ t_a9il[tau:2]
  arising from a type equality Natural ~ t_a9il[tau:2]
u_tys
  tclvl 2
  Type ~ Type
  arising from a kind equality arising from t_a9il[tau:2] ~ Natural
u_tys yields no coercion
uUnfilledVar2 ok
  t_a9il[tau:2] :: Type
  Natural :: Type
  True
  <Type>_N
writeMetaTyVar t_a9il[tau:2] :: Type := Natural
u_tys yields no coercion
checkExpectedKind
  Natural
  t_a9il[tau:2]
  <Natural>_N
tcInferTyApps (vis normal app) 2 t_a9il[tau:2]
tcInferTyApps } a_a99N[sk:2] <= 1 :: Constraint
checkExpectedKind
  a_a99N[sk:2] <= 1
  Constraint
checkExpectedKindX
  a_a99N <= 1
  act_kind': Constraint
  exp_kind: Constraint
newAnonMetaTyVar t_a9im[tau:2]
tc_hs_type tuple 2 []
finish_tuple
  BoxedTuple
  []
  TYPE t_a9im[tau:2]
checkExpectedKind
  ()
  Type
checkExpectedKindX
  ()
  act_kind': Type
  exp_kind: TYPE t_a9im[tau:2]
u_tys
  tclvl 2
  Type ~ TYPE t_a9im[tau:2]
  arising from a type equality Type ~ TYPE t_a9im[tau:2]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.LiftedRep ~ t_a9im[tau:2]
  arising from a type equality Type ~ TYPE t_a9im[tau:2]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.RuntimeRep ~ ghc-prim:GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a9im[tau:2] ~ ghc-prim:GHC.Types.LiftedRep
u_tys yields no coercion
uUnfilledVar2 ok
  t_a9im[tau:2] :: ghc-prim:GHC.Types.RuntimeRep
  ghc-prim:GHC.Types.LiftedRep :: ghc-prim:GHC.Types.RuntimeRep
  True
  <ghc-prim:GHC.Types.RuntimeRep>_N
writeMetaTyVar
  t_a9im[tau:2] :: ghc-prim:GHC.Types.RuntimeRep := ghc-prim:GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  Type
  TYPE t_a9im[tau:2]
  <Type>_N
checkExpectedKind
  (a_a99N[sk:2] <= 1) => ()
  Type
checkExpectedKindX
  ()
  act_kind': Type
  exp_kind: TYPE t_a9ij[tau:1]
u_tys
  tclvl 2
  Type ~ TYPE t_a9ij[tau:1]
  arising from a type equality Type ~ TYPE t_a9ij[tau:1]
u_tys
  tclvl 2
  ghc-prim:GHC.Types.LiftedRep ~ t_a9ij[tau:1]
  arising from a type equality Type ~ TYPE t_a9ij[tau:1]
uUnfilledVar2 not ok
  t_a9ij[tau:1]
  ghc-prim:GHC.Types.LiftedRep
New coercion hole:
  co_a9in :: ghc-prim:GHC.Types.LiftedRep
             ghc-prim:GHC.Prim.~# t_a9ij[tau:1]
utype_defer
  ghc-prim:GHC.Types.LiftedRep
  t_a9ij[tau:1]
  arising from a type equality Type ~ TYPE t_a9ij[tau:1]
  In the type signature: bar :: a_a99N <= 1 => ()
utype_defer2 {co_a9in}
u_tys yields coercion: {co_a9in}
u_tys yields coercion: (TYPE {co_a9in})_N
checkExpectedKind
  Type
  TYPE t_a9ij[tau:1]
  (TYPE {co_a9in})_N
pushLevelAndCaptureConstraints } 2
newNoTcEvBinds unique = a9io
newNoTcEvBinds unique = a9ip
solveWanteds {
  Level = 1
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                          ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                          ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 2
    Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                    ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
    Binds = CoEvBindsVar<a9io>
    the type signature for ‘bar’ }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveWanteds {
  Level = 2
  WC {wc_simple =
        [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
solveSimpleWanteds {
  {[W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                           ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 2
  work item = [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                      ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                                        ghc-prim:GHC.Prim.~# t_a9ij[tau:1] (CNonCanonical)
canEvNC:eq
  ghc-prim:GHC.Types.LiftedRep
  t_a9ij[tau:1]
can_eq_nc
  False
  [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                          ghc-prim:GHC.Prim.~# t_a9ij[tau:1]
  nominal equality
  ghc-prim:GHC.Types.LiftedRep
  ghc-prim:GHC.Types.LiftedRep
  t_a9ij[tau:1]
  t_a9ij[tau:1]
rewrite { ghc-prim:GHC.Types.LiftedRep
rewrite } ghc-prim:GHC.Types.LiftedRep
rewrite { t_a9ij[tau:1]
Unfilled tyvar (t_a9ij[tau:1] :: ghc-prim:GHC.Types.RuntimeRep)
rewrite } t_a9ij[tau:1]
New coercion hole:
  co_a9iq :: t_a9ij[tau:1]
             ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
Emitting new coercion hole
  {co_a9iq} :: t_a9ij[tau:1]
               ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
Filling coercion hole co_a9in := Sym {co_a9iq}
rewriteEqEvidence
  [W] hole{co_a9in} {0}:: ghc-prim:GHC.Types.LiftedRep
                          ghc-prim:GHC.Prim.~# t_a9ij[tau:1]
  t_a9ij[tau:1]
  ghc-prim:GHC.Types.LiftedRep
  Sym {co_a9iq}
  {}
CEqCan
  t_a9ij[tau:1]
  ghc-prim:GHC.Types.LiftedRep
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] hole{co_a9iq} {0}:: t_a9ij[tau:1]
                                        ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep (CEqCan)
tryToSolveByUnification
  t_a9ij[tau:1] ~ ghc-prim:GHC.Types.LiftedRep
  TouchableOuterLevel(1 [])
Sneaky unification:
  Unifies: t_a9ij[tau:1] := ghc-prim:GHC.Types.LiftedRep
  Coercion: t_a9ij[tau:1] ~ ghc-prim:GHC.Types.LiftedRep
  Left Kind is: ghc-prim:GHC.Types.RuntimeRep
  Right Kind is: ghc-prim:GHC.Types.RuntimeRep
unifyTyVar t_a9ij[tau:1] := ghc-prim:GHC.Types.LiftedRep
writeMetaTyVar
  t_a9ij[tau:1] :: ghc-prim:GHC.Types.RuntimeRep := ghc-prim:GHC.Types.LiftedRep
Filling coercion hole co_a9iq := <ghc-prim:GHC.Types.LiftedRep>_N
end stage interact with inerts }
Step 1[l:2,d:0] Solved by unification:
    [W] hole{co_a9iq} {0}:: t_a9ij[tau:1]
                            ghc-prim:GHC.Prim.~# ghc-prim:GHC.Types.LiftedRep
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
resetUnificationFlag
  ambient: 2
  unif_lvl: Just 1
unif_happened False
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getHasGivenEqs
  given_eqs: False
  ge_lvl: 0
  ambient level: 2
  Inerts: {Innermost given equalities = 0
           Given eqs at this level = False}
  Insols: {}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 2
    Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = CoEvBindsVar<a9io>
    the type signature for ‘bar’ }
neededEvVars
  old_needs: {}
  seeds3: {co_a9iq}
  tcvs: {co_a9iq}
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 2
                Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                Given-eqs = NoGivenEqs
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = CoEvBindsVar<a9io>
                the type signature for ‘bar’ }
solveImplication end }
  has_given_eqs = NoGivenEqs
  res_implic = Just Implic {
                      TcLevel = 2
                      Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                      Given-eqs = NoGivenEqs
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = CoEvBindsVar<a9io>
                      the type signature for ‘bar’ }
  implication evbinds = {}
  implication tvcs = {co_a9iq}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9io>
                             the type signature for ‘bar’ }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Just 1
unif_happened True
simplify_loop iteration=1 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9io>
                             the type signature for ‘bar’ }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 2
                     Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9io>
                     the type signature for ‘bar’ }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99N[sk:2] :: Natural)
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9io>
                    the type signature for ‘bar’ }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
Constraint solver steps = 1
pushLevelAndSolveEqualities }
  Residual: WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9io>
                    the type signature for ‘bar’ }}
  Level: 1
doNotQuantifyTyVars has nothing to error on
tc_lhs_sig_type
  HsOuterImplicit: [a_a99N]
  HsOuterImplicit: [a_a99N[sk:2]]
quantifyTyVars has nothing to quantify
newNoTcEvBinds unique = a9ir
tcHsSigType 2
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9io>
              the type signature for ‘bar’ }}
    Binds = CoEvBindsVar<a9ir>
    the type signature for ‘bar’ }
newNoTcEvBinds unique = a9is
solveWanteds {
  Level = 0
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9io>
                    the type signature for ‘bar’ }}
          Binds = CoEvBindsVar<a9ir>
          the type signature for ‘bar’ }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                    Given-eqs = NoGivenEqs
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = CoEvBindsVar<a9io>
                    the type signature for ‘bar’ }}
          Binds = CoEvBindsVar<a9ir>
          the type signature for ‘bar’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9io>
              the type signature for ‘bar’ }}
    Binds = CoEvBindsVar<a9ir>
    the type signature for ‘bar’ }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveWanteds {
  Level = 1
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 2
                             Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9io>
                             the type signature for ‘bar’ }}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 2
                     Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9io>
                     the type signature for ‘bar’ }}
  current evbinds  = {}
getHasGivenEqs
  given_eqs: False
  ge_lvl: 0
  ambient level: 1
  Inerts: {Innermost given equalities = 0
           Given eqs at this level = False}
  Insols: {}
solveImplication 2
  {}
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9io>
          the type signature for ‘bar’ }}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems =
    Given-eqs = NoGivenEqs
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 2
              Skolems = (a_a99N[sk:2] :: k_a9ik[tau:2])
              Given-eqs = NoGivenEqs
              Status = Solved {Dead givens = []}
              Given =
              Wanted = WC {}
              Binds = CoEvBindsVar<a9io>
              the type signature for ‘bar’ }}
    Binds = CoEvBindsVar<a9ir>
    the type signature for ‘bar’ }
neededEvVars
  old_needs: {}
  seeds3: {co_a9iq}
  tcvs: {}
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems =
                Given-eqs = NoGivenEqs
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = CoEvBindsVar<a9ir>
                the type signature for ‘bar’ }
solveImplication end }
  has_given_eqs = NoGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems =
                      Given-eqs = NoGivenEqs
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = CoEvBindsVar<a9ir>
                      the type signature for ‘bar’ }
  implication evbinds = {}
  implication tvcs = {}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems =
                             Given-eqs = NoGivenEqs
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = CoEvBindsVar<a9ir>
                             the type signature for ‘bar’ }}
resetUnificationFlag
  ambient: 0
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems =
                     Given-eqs = NoGivenEqs
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = CoEvBindsVar<a9ir>
                     the type signature for ‘bar’ }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
emitFlatConstraints {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems =
          Given-eqs = NoGivenEqs
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = CoEvBindsVar<a9ir>
          the type signature for ‘bar’ }}
emitFlatConstraints }
  simples: {}
  errs:    {}
emitDelayedErrors {}
checkValidType forall (a :: Natural). (a <= 1) => () :: Type
check_type
  forall (a :: Natural). (a <= 1) => ()
  ArbitraryRank
check_valid_theta [a_a99N[sk:2] <= 1]
done ct forall (a :: Natural). (a <= 1) => ()
Ambiguity check for forall (a :: Natural). (a <= 1) => ()
tc_sub_type (general case)
  ty_actual   = forall (a :: Natural). (a <= 1) => ()
  ty_expected = forall (a :: Natural). (a <= 1) => ()
pushLevelAndCaptureConstraints { 1
cloneAnonMetaTyVar a_a9iw[tau:1] :: Natural
instCallConstraints [irred_a9ix]
Instantiating
  origin arising from a type ambiguity check for
         the type signature for ‘bar’
  tvs [a_a99N[sk:2]]
  theta [a_a99N[sk:2] <= 1]
  type ()
  with a_a9iw[tau:1]
  theta: [a_a9iw[tau:1] <= 1]
u_tys
  tclvl 1
  () ~ ()
  arising from a type equality () ~ ()
u_tys yields no coercion
pushLevelAndCaptureConstraints } 1
newTcEvBinds unique = a9iy
checkConstraints
  1
  [a_a9it[sk:1]]
simplifyAmbiguityCheck {
  type =  forall (a :: Natural). (a <= 1) => ()
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9it[sk:1] :: Natural)
                    Given-eqs = MaybeGivenEqs
                    Status = Unsolved
                    Given = irred_a9iu :: a_a9it[sk:1] <= 1
                    Wanted =
                      WC {wc_simple =
                            [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
                    Binds = EvBindsVar<a9iy>
                    the type signature for:
                      bar :: forall (a :: Natural). (a <= 1) => () }}
newTcEvBinds unique = a9iz
solveWanteds {
  Level = 0
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9it[sk:1] :: Natural)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iu :: a_a9it[sk:1] <= 1
          Wanted =
            WC {wc_simple =
                  [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
          Binds = EvBindsVar<a9iy>
          the type signature for:
            bar :: forall (a :: Natural). (a <= 1) => () }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9it[sk:1] :: Natural)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iu :: a_a9it[sk:1] <= 1
          Wanted =
            WC {wc_simple =
                  [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
          Binds = EvBindsVar<a9iy>
          the type signature for:
            bar :: forall (a :: Natural). (a <= 1) => () }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (a_a9it[sk:1] :: Natural)
    Given-eqs = MaybeGivenEqs
    Status = Unsolved
    Given = irred_a9iu :: a_a9it[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
    Binds = EvBindsVar<a9iy>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveSimpleGivens {
  [[G] irred_a9iu {0}:: a_a9it[sk:1] <= 1 (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] irred_a9iu {0}:: a_a9it[sk:1] <= 1 (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] irred_a9iu {0}:: a_a9it[sk:1]
                                     <= 1 (CNonCanonical)
canEvNC:irred a_a9it[sk:1] <= 1
can_pred IrredPred =  a_a9it[sk:1] <= 1
rewrite { a_a9it[sk:1] <= 1
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9it[sk:1] <=? 1) (Data.Type.Ord.LeErrMsg a_a9it[sk:1] 1)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9it[sk:1] 1) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9it[sk:1] 1
  Match succeeded:
    Rewrites to: CmpNat a_a9it[sk:1] 1
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9it[sk:1]>_N <1>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Natural, a_a9it[sk:1], 1]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9it[sk:1] 1
    reductionReducedType: CmpNat a_a9it[sk:1] 1
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9it[sk:1]>_N <1>_N}
matchFamTcM
  Matching: CmpNat a_a9it[sk:1] 1
  Match failed
Unfilled tyvar (a_a9it[sk:1] :: Natural)
matchFamTcM
  Matching: CmpNat a_a9it[sk:1] 1
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9it[sk:1] 1) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9it[sk:1] :: Natural)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
    (TypeError ...)
addTcEvBind
  a9iy
  [G] irred_a9iA
    = irred_a9iu
      `cast` ((GHC.TypeError.Assert
                 (Data.Type.Ord.OrdCond
                    <Bool>_N
                    (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9it[sk:1]>_N <1>_N)
                    <True>_N
                    <True>_N
                    <False>_N)_N
                 <(TypeError ...)>_N)_R
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond
                      (Data.Type.Ord.Compare a_a9it[sk:1] 1) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9it[sk:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9it[sk:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [G] irred_a9iA {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                         (TypeError ...) (CIrredCan(irred))
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9it[sk:1] 1)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 1[l:1,d:0] Kept as inert:
    [G] irred_a9iA {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9it[sk:1] 1) True True False)
                                      (TypeError ...) (CIrredCan(irred))
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
End solveSimpleGivens }
solveWanteds {
  Level = 1
  WC {wc_simple =
        [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
solveSimpleWanteds {
  {[W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [W] irred_a9ix {0}:: a_a9iw[tau:1] <= 1 (CNonCanonical)
  inerts = {Irreds = [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9it[sk:1] 1) True True False)
                                            (TypeError ...) (CIrredCan(irred))
            Innermost given equalities = 0
            Given eqs at this level = True}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] irred_a9ix {0}:: a_a9iw[tau:1]
                                     <= 1 (CNonCanonical)
canEvNC:irred a_a9iw[tau:1] <= 1
can_pred IrredPred =  a_a9iw[tau:1] <= 1
rewrite { a_a9iw[tau:1] <= 1
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9iw[tau:1] <=? 1) (Data.Type.Ord.LeErrMsg a_a9iw[tau:1] 1)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9iw[tau:1] 1) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9iw[tau:1] 1
  Match succeeded:
    Rewrites to: CmpNat a_a9iw[tau:1] 1
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9iw[tau:1]>_N <1>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Natural, a_a9iw[tau:1], 1]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9iw[tau:1] 1
    reductionReducedType: CmpNat a_a9iw[tau:1] 1
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9iw[tau:1]>_N <1>_N}
matchFamTcM
  Matching: CmpNat a_a9iw[tau:1] 1
  Match failed
Unfilled tyvar (a_a9iw[tau:1] :: Natural)
matchFamTcM
  Matching: CmpNat a_a9iw[tau:1] 1
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9iw[tau:1] 1) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9iw[tau:1] :: Natural)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
    (TypeError ...)
Emitting new wanted
  irred_a9iB :: GHC.TypeError.Assert
                  (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                  (TypeError ...)
  arising from a type ambiguity check for
  the type signature for ‘bar’
  at src/Protocols/Extra/PacketStream/Packetizers.hs:470:8-19
addTcEvBind
  a9iy
  [W] irred_a9ix
    = irred_a9iB
      `cast` (Sub (Sym (GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             <Bool>_N
                             (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9iw[tau:1]>_N <1>_N)
                             <True>_N
                             <True>_N
                             <False>_N)_N
                          <(TypeError ...)>_N)_N)
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond
                          (Data.Type.Ord.Compare a_a9iw[tau:1] 1) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iw[tau:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iw[tau:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [W] irred_a9iB {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                         (TypeError ...) (CIrredCan(irred))
No local instance for
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
    (TypeError ...)
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9iw[tau:1] 1)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 2[l:1,d:0] Kept as inert:
    [W] irred_a9iB {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9iw[tau:1] 1) True True False)
                                      (TypeError ...) (CIrredCan(irred))
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[W] irred_a9iB {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
  implics = {}
zonkSimples done:
  {[W] irred_a9iB {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                          (TypeError ...) (CIrredCan(irred))}
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9iB {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyExtra
  [NatInequality
   a_a9it[sk:1]
   1
   True
   Untouched,
   NatInequality
   a_a9iw[tau:1]
   1
   True
   Untouched]
unifyExtra leq result (a_a9it[sk:1], 1, True)
unifyExtra leq result (a_a9iw[tau:1], 1, True)
normalised
  Simplified
  Solved:
  []
  New:
  []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9iB {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyNats
  [(Right ([G] irred_a9iA {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (a_a9it[sk:1], 1, True)),
    []),
   (Right ([W] irred_a9iB {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (a_a9iw[tau:1], 1, True)),
    [])]
unifyNats(ineq) results
  ([G] irred_a9iA {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   (a_a9it[sk:1], 1, True),
   1 + -1 * a_a9it[sk:1],
   [(a_a9it[sk:1], 1, True)])
unifyNats(ineq) results
  ([W] irred_a9iB {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   (a_a9iw[tau:1], 1, True),
   1 + -1 * a_a9iw[tau:1],
   [(a_a9it[sk:1], 1, True), (a_a9it[sk:1], 1, True),
    (a_a9it[sk:1], 1, True)])
normalised
  Simplified
  [((ghc-prim:GHC.Classes.(%%)
     `cast` (Univ(representational plugin "ghc-typelits-natnormalise"
                  :: () :: Constraint, GHC.TypeError.Assert
                                         (Data.Type.Ord.OrdCond
                                            (CmpNat a_a9it[sk:1] 1) True True False)
                                         (TypeError ...))
             :: (() :: Constraint)
                ~R# GHC.TypeError.Assert
                      (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                      (TypeError ...)),
     [G] irred_a9iA {0}:: GHC.TypeError.Assert
                            (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                            (TypeError ...) (CIrredCan(irred))),
    [])]
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9iA {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9it[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9iB {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9iw[tau:1] 1) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_simple =
                   [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9iw[tau:1] 1) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
  current evbinds  = {[G] irred_a9iA
                        = irred_a9iu
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9it[sk:1]>_N <1>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9it[sk:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9it[sk:1] 1) True True False)
                                           (TypeError ...)),
                      [W] irred_a9ix
                        = irred_a9iB
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9iw[tau:1]>_N <1>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iw[tau:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare a_a9iw[tau:1] 1)
                                              True
                                              True
                                              False)
                                           (TypeError ...))}
getHasGivenEqs
  given_eqs: True
  ge_lvl: 0
  ambient level: 1
  Inerts: {Irreds = [G] irred_a9iA {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9it[sk:1] 1) True True False)
                                           (TypeError ...) (CIrredCan(irred))
           Innermost given equalities = 0
           Given eqs at this level = True}
  Insols: {}
solveImplication 2
  {}
  WC {wc_simple =
        [W] irred_a9iB {0}:: GHC.TypeError.Assert
                               (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                               (TypeError ...) (CIrredCan(irred))}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9it[sk:1] :: Natural)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iu :: a_a9it[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iy>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
neededEvVars
  old_needs: {}
  seeds3: {irred_a9iB}
  tcvs: {}
  ev_binds: [a9iA :-> [G] irred_a9iA
                        = irred_a9iu
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9it[sk:1]>_N <1>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9it[sk:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9it[sk:1] 1) True True False)
                                           (TypeError ...)),
             a9ix :-> [W] irred_a9ix
                        = irred_a9iB
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9iw[tau:1]>_N <1>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iw[tau:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare a_a9iw[tau:1] 1)
                                              True
                                              True
                                              False)
                                           (TypeError ...))]
  live_ev_binds: [a9ix :-> [W] irred_a9ix
                             = irred_a9iB
                               `cast` (Sub (Sym (GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      <Bool>_N
                                                      (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                           <a_a9iw[tau:1]>_N <1>_N)
                                                      <True>_N
                                                      <True>_N
                                                      <False>_N)_N
                                                   <(TypeError ...)>_N)_N)
                                       :: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9iw[tau:1] 1) True True False)
                                            (TypeError ...)
                                          ~R# GHC.TypeError.Assert
                                                (Data.Type.Ord.OrdCond
                                                   (Data.Type.Ord.Compare a_a9iw[tau:1] 1)
                                                   True
                                                   True
                                                   False)
                                                (TypeError ...))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = (a_a9it[sk:1] :: Natural)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iu :: a_a9it[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iw[tau:1] 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iy>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
solveImplication end }
  has_given_eqs = LocalGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (a_a9it[sk:1] :: Natural)
                      Given-eqs = LocalGivenEqs
                      Status = Unsolved
                      Given = irred_a9iu :: a_a9it[sk:1] <= 1
                      Wanted =
                        WC {wc_simple =
                              [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                                     (Data.Type.Ord.OrdCond
                                                        (CmpNat a_a9iw[tau:1] 1) True True False)
                                                     (TypeError ...) (CIrredCan(irred))}
                      Binds = EvBindsVar<a9iy>
                      the type signature for:
                        bar :: forall (a :: Natural). (a <= 1) => () }
  implication evbinds = {[W] irred_a9ix
                           = irred_a9iB
                             `cast` (Sub (Sym (GHC.TypeError.Assert
                                                 (Data.Type.Ord.OrdCond
                                                    <Bool>_N
                                                    (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                         <a_a9iw[tau:1]>_N <1>_N)
                                                    <True>_N
                                                    <True>_N
                                                    <False>_N)_N
                                                 <(TypeError ...)>_N)_N)
                                     :: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9iw[tau:1] 1) True True False)
                                          (TypeError ...)
                                        ~R# GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 (Data.Type.Ord.Compare a_a9iw[tau:1] 1)
                                                 True
                                                 True
                                                 False)
                                              (TypeError ...))}
  implication tvcs = {}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_a9it[sk:1] :: Natural)
                             Given-eqs = LocalGivenEqs
                             Status = Unsolved
                             Given = irred_a9iu :: a_a9it[sk:1] <= 1
                             Wanted =
                               WC {wc_simple =
                                     [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                                            (Data.Type.Ord.OrdCond
                                                               (CmpNat a_a9iw[tau:1] 1)
                                                               True
                                                               True
                                                               False)
                                                            (TypeError ...) (CIrredCan(irred))}
                             Binds = EvBindsVar<a9iy>
                             the type signature for:
                               bar :: forall (a :: Natural). (a <= 1) => () }}
resetUnificationFlag
  ambient: 0
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (a_a9it[sk:1] :: Natural)
                     Given-eqs = LocalGivenEqs
                     Status = Unsolved
                     Given = irred_a9iu :: a_a9it[sk:1] <= 1
                     Wanted =
                       WC {wc_simple =
                             [W] irred_a9iB {0}:: GHC.TypeError.Assert
                                                    (Data.Type.Ord.OrdCond
                                                       (CmpNat a_a9iw[tau:1] 1) True True False)
                                                    (TypeError ...) (CIrredCan(irred))}
                     Binds = EvBindsVar<a9iy>
                     the type signature for:
                       bar :: forall (a :: Natural). (a <= 1) => () }}
  current evbinds  = {}
Constraint solver steps = 2
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall (a :: Natural). (a <= 1) => ()
checkValidType done forall (a :: Natural). (a <= 1) => () :: Type
end tcHsSigType } forall (a :: Natural). (a <= 1) => ()
tcuser forall (a :: Natural). (a <= 1) => ()
tc_extend_local_env
  [(foo,
    Identifier[foo::forall (a :: Nat).
                    (a <= 0) =>
                    (), TopLevelLet {} True]),
   (bar,
    Identifier[bar::forall (a :: Natural).
                    (a <= 1) =>
                    (), TopLevelLet {} True])]
------------------------------------------------
Bindings for { [bar]
Generalisation plan
  CheckGen bar :: forall (a :: Natural). (a <= 1) => ()
tcPolyCheck
  bar
  src/Protocols/Extra/PacketStream/Packetizers.hs:470:1-19
pushLevelAndCaptureConstraints { 1
tc_extend_local_env
  [(a_a99N, Type variable ‘a_a99N’ = a_a9iD[sk:1] :: Natural)]
tcExtendBinderStack [a_a99N a_a9iD[sk:1]]
tcExtendBinderStack [bar_a9iC[<NotTopLevel>]]
tcMatchesFun
  bar_a9iC
  Check{()}
tcBody Check{()}
tcApp {
  rn_fun: undefined
  rn_args: []
tcInferId undefined :: forall a. GHC.Stack.Types.HasCallStack => a
tcInstFun
  undefined
  forall a. GHC.Stack.Types.HasCallStack => a
  args: []
  do_ql False
cloneAnonMetaTyVar a_a9iH[tau:1] :: Type
instCallConstraints [$dIP_a9iO]
Instantiating
  origin arising from a use of ‘undefined’
  tvs [a_i9iG]
  theta [GHC.Stack.Types.HasCallStack]
  type a_i9iG
  with a_a9iH[tau:1]
  theta: [GHC.Stack.Types.HasCallStack]
tcInstFun:ret a_a9iH[tau:1]
tc_sub_type_deep (general case)
  ty_actual   = a_a9iH[tau:1]
  ty_expected = ()
tc_sub_type_ds
  ty_actual   = a_a9iH[tau:1]
  ty_expected = ()
u_tys
  tclvl 1
  a_a9iH[tau:1] ~ ()
  arising from a type equality a_a9iH[tau:1] ~ ()
u_tys
  tclvl 1
  Type ~ Type
  arising from a kind equality arising from a_a9iH[tau:1] ~ ()
u_tys yields no coercion
uUnfilledVar2 ok
  a_a9iH[tau:1] :: Type
  () :: Type
  True
  <Type>_N
writeMetaTyVar a_a9iH[tau:1] :: Type := ()
u_tys yields no coercion
tcApp }
  rn_fun: undefined
  rn_args: []
  inst_args [EHsWrap <>]
  do_ql:   False
  fun_sigma:   forall a. GHC.Stack.Types.HasCallStack => a
  delta:       {a_a9iH[tau:1]}
  app_res_rho: a_a9iH[tau:1]
  exp_res_ty: Check{()}
  rn_expr: undefined
  tc_fun: undefined
  tc_args: [EHsWrap <>]
  tc_expr: undefined
tcScalingUsage Many
pushLevelAndCaptureConstraints } 1
newTcEvBinds unique = a9iP
checkConstraints
  1
  [a_a9iD[sk:1]]
tcSpecPrags bar []
} End of bindings for
  [bar]
  NonRecursive
  bar forall (a :: Natural). (a <= 1) => ()
tcExtendBinderStack [bar[<TopLevel>]]
tc_extend_local_env
  [(bar,
    Identifier[bar::forall (a :: Natural).
                    (a <= 1) =>
                    (), TopLevelLet])]
------------------------------------------------
Bindings for { [foo]
Generalisation plan
  CheckGen foo :: forall (a :: Nat). (a <= 0) => ()
tcPolyCheck
  foo
  src/Protocols/Extra/PacketStream/Packetizers.hs:473:1-38
pushLevelAndCaptureConstraints { 1
tc_extend_local_env
  [(a_a99M, Type variable ‘a_a99M’ = a_a9iR[sk:1] :: Nat)]
tcExtendBinderStack [a_a99M a_a9iR[sk:1]]
tcExtendBinderStack [foo_a9iQ[<NotTopLevel>]]
tcMatchesFun
  foo_a9iQ
  Check{()}
tcBody Check{()}
tcApp {
  rn_fun: bar
  rn_args: [@(a_a99M + 1)]
tcInferId bar :: forall (a :: Natural). (a <= 1) => ()
tcInstFun
  bar
  forall (a :: Natural). (a <= 1) => ()
  args: [@(a_a99M + 1)]
  do_ql False
solveEqualities { Called from tcHsTypeApp
tc_extend_local_env []
tcExtendBinderStack []
lk1 +
tcInferTyApps {
  (+)
  [HsValArg a_a99M, HsValArg 1]
tcInferTyApps (vis normal app)
  [->] Natural
  a_a99M
  Natural
  <InScope = {}
   IdSubst   = []
   TvSubst   = []
   CvSubst   = []>
lk1 a_a99M
tcInferTyApps {
  a_a99M
  []
tcInferTyApps } a_a9iR[sk:1] :: Nat
checkExpectedKind
  a_a9iR[sk:1]
  Nat
checkExpectedKindX
  a_a99M
  act_kind': Nat
  exp_kind: Natural
tcInferTyApps (vis normal app) 2 Natural
tcInferTyApps (vis normal app)
  [->] Natural
  1
  Natural
  <InScope = {}
   IdSubst   = []
   TvSubst   = []
   CvSubst   = []>
checkExpectedKind
  1
  Natural
checkExpectedKindX
  1
  act_kind': Natural
  exp_kind: Natural
tcInferTyApps (vis normal app) 2 Natural
tcInferTyApps } a_a9iR[sk:1] + 1 :: Natural
checkExpectedKind
  a_a9iR[sk:1] + 1
  Natural
checkExpectedKindX
  a_a99M + 1
  act_kind': Natural
  exp_kind: Natural
newNoTcEvBinds unique = a9iU
solveWanteds {
  Level = 1
  WC {}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc = WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
zonkSimples done: {}
emitFlatConstraints { WC {}
emitFlatConstraints }
  simples: {}
  errs:    {}
emitDelayedErrors {}
solveEqualities }
kindGeneralizeNone a_a9iR[sk:1] + 1
checkValidType a_a9iR[sk:1] + 1 :: Natural
done ct a_a9iR[sk:1] + 1
checkValidType done a_a9iR[sk:1] + 1 :: Natural
VTA
  fun_ty forall (a :: Natural). (a <= 1) => ()
  tv a_a99N[sk:2] :: Natural
  ty_arg + a_a9iR[sk:1] 1 :: Natural
  inner_ty <= Natural a_a99N[sk:2] 1 => ()
  insted_ty <= Natural (+ a_a9iR[sk:1] 1) 1 => ()
instCallConstraints [irred_a9iV]
Instantiating
  origin arising from a use of ‘bar’
  tvs []
  theta [(a_a9iR[sk:1] + 1) <= 1]
  type ()
  with
  theta: [(a_a9iR[sk:1] + 1) <= 1]
tcInstFun:ret ()
tc_sub_type_deep (general case)
  ty_actual   = ()
  ty_expected = ()
tc_sub_type_ds
  ty_actual   = ()
  ty_expected = ()
u_tys
  tclvl 1
  () ~ ()
  arising from a type equality () ~ ()
u_tys yields no coercion
tcApp }
  rn_fun: bar
  rn_args: [@(a_a99M + 1)]
  inst_args [@(a_a99M + 1), EHsWrap <>]
  do_ql:   False
  fun_sigma:   forall (a :: Natural). (a <= 1) => ()
  delta:       {}
  app_res_rho: ()
  exp_res_ty: Check{()}
  rn_expr: bar @(a_a99M + 1)
  tc_fun: bar
  tc_args: [@(a_a99M + 1), EHsWrap <>]
  tc_expr: bar @(a_a99M + 1)
tcScalingUsage Many
pushLevelAndCaptureConstraints } 1
newTcEvBinds unique = a9iW
checkConstraints
  1
  [a_a9iR[sk:1]]
tcSpecPrags foo []
} End of bindings for
  [foo]
  NonRecursive
  foo forall (a :: Nat). (a <= 0) => ()
tcExtendBinderStack [foo[<TopLevel>]]
tc_extend_local_env
  [(foo,
    Identifier[foo::forall (a :: Nat). (a <= 0) => (), TopLevelLet])]
complete_matches
  [(NonRecursive, {bar = undefined}),
   (NonRecursive, {foo = bar @(a_a99M + 1)})]
  [foo :: forall (a_a99M :: Nat). a_a99M <= 0 => (),
   bar :: a_a99N <= 1 => ()]
complete_matches []
tcExtendKindEnvList []
tc_extend_local_env []
complete_matches
  []
  []
complete_matches []
Tc6
Tc7
Tc7a
simplifyTop {
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9iD[sk:1] :: Natural)
                    Given-eqs = MaybeGivenEqs
                    Status = Unsolved
                    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                    Wanted =
                      WC {wc_simple =
                            [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
                    Binds = EvBindsVar<a9iP>
                    the type signature for:
                      bar :: forall (a :: Natural). (a <= 1) => () }
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9iR[sk:1] :: Nat)
                    Given-eqs = MaybeGivenEqs
                    Status = Unsolved
                    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                    Wanted =
                      WC {wc_simple =
                            [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
                    Binds = EvBindsVar<a9iW>
                    the type signature for:
                      foo :: forall (a :: Nat). (a <= 0) => () }}
newTcEvBinds unique = a9iX
solveWanteds {
  Level = 0
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9iD[sk:1] :: Natural)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iE :: a_a9iD[sk:1] <= 1
          Wanted =
            WC {wc_simple =
                  [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
          Binds = EvBindsVar<a9iP>
          the type signature for:
            bar :: forall (a :: Natural). (a <= 1) => () }
        Implic {
          TcLevel = 1
          Skolems = (a_a9iR[sk:1] :: Nat)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iS :: a_a9iR[sk:1] <= 0
          Wanted =
            WC {wc_simple =
                  [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
          Binds = EvBindsVar<a9iW>
          the type signature for:
            foo :: forall (a :: Nat). (a <= 0) => () }}
simplify_loop iteration=0 (definitely_redo = True, 0 simples to solve)
simplify_loop: wc =
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9iD[sk:1] :: Natural)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iE :: a_a9iD[sk:1] <= 1
          Wanted =
            WC {wc_simple =
                  [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
          Binds = EvBindsVar<a9iP>
          the type signature for:
            bar :: forall (a :: Natural). (a <= 1) => () }
        Implic {
          TcLevel = 1
          Skolems = (a_a9iR[sk:1] :: Nat)
          Given-eqs = MaybeGivenEqs
          Status = Unsolved
          Given = irred_a9iS :: a_a9iR[sk:1] <= 0
          Wanted =
            WC {wc_simple =
                  [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
          Binds = EvBindsVar<a9iW>
          the type signature for:
            foo :: forall (a :: Nat). (a <= 0) => () }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iD[sk:1] :: Natural)
    Given-eqs = MaybeGivenEqs
    Status = Unsolved
    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
    Binds = EvBindsVar<a9iP>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveSimpleGivens {
  [[G] irred_a9iE {0}:: a_a9iD[sk:1] <= 1 (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] irred_a9iE {0}:: a_a9iD[sk:1] <= 1 (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] irred_a9iE {0}:: a_a9iD[sk:1]
                                     <= 1 (CNonCanonical)
canEvNC:irred a_a9iD[sk:1] <= 1
can_pred IrredPred =  a_a9iD[sk:1] <= 1
rewrite { a_a9iD[sk:1] <= 1
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9iD[sk:1] <=? 1) (Data.Type.Ord.LeErrMsg a_a9iD[sk:1] 1)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9iD[sk:1] 1) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9iD[sk:1] 1
  Match succeeded:
    Rewrites to: CmpNat a_a9iD[sk:1] 1
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9iD[sk:1]>_N <1>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Natural, a_a9iD[sk:1], 1]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9iD[sk:1] 1
    reductionReducedType: CmpNat a_a9iD[sk:1] 1
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9iD[sk:1]>_N <1>_N}
matchFamTcM
  Matching: CmpNat a_a9iD[sk:1] 1
  Match failed
Unfilled tyvar (a_a9iD[sk:1] :: Natural)
matchFamTcM
  Matching: CmpNat a_a9iD[sk:1] 1
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9iD[sk:1] 1) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9iD[sk:1] :: Natural)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
    (TypeError ...)
addTcEvBind
  a9iP
  [G] irred_a9iY
    = irred_a9iE
      `cast` ((GHC.TypeError.Assert
                 (Data.Type.Ord.OrdCond
                    <Bool>_N
                    (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9iD[sk:1]>_N <1>_N)
                    <True>_N
                    <True>_N
                    <False>_N)_N
                 <(TypeError ...)>_N)_R
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond
                      (Data.Type.Ord.Compare a_a9iD[sk:1] 1) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iD[sk:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iD[sk:1] 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [G] irred_a9iY {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                         (TypeError ...) (CIrredCan(irred))
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9iD[sk:1] 1)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 1[l:1,d:0] Kept as inert:
    [G] irred_a9iY {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9iD[sk:1] 1) True True False)
                                      (TypeError ...) (CIrredCan(irred))
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
End solveSimpleGivens }
solveWanteds {
  Level = 1
  WC {wc_simple =
        [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
solveSimpleWanteds {
  {[W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
  inerts = {Irreds = [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9iD[sk:1] 1) True True False)
                                            (TypeError ...) (CIrredCan(irred))
            Innermost given equalities = 0
            Given eqs at this level = True}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] $dIP_a9iO {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
canEvNC:cls
  ghc-prim:GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
Emitting new wanted
  $dIP_a9iZ :: GHC.Stack.Types.HasCallStack
  arising from a use of implicit parameter ‘?callStack’
  at src/Protocols/Extra/PacketStream/Packetizers.hs:471:7-15
addTcEvBind
  a9iP
  [W] $dIP_a9iO
    = (GHC.Stack.Types.pushCallStack
         (ghc-prim:GHC.CString.unpackCString# "undefined"#,
          GHC.Stack.Types.SrcLoc
            (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
            (ghc-prim:GHC.CString.unpackCString#
               "Protocols.Extra.PacketStream.Packetizers"#)
            (ghc-prim:GHC.CString.unpackCString#
               "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
            (ghc-prim:GHC.Types.I# 471#)
            (ghc-prim:GHC.Types.I# 7#)
            (ghc-prim:GHC.Types.I# 471#)
            (ghc-prim:GHC.Types.I# 16#))
         ($dIP_a9iZ
          `cast` (ghc-prim:GHC.Classes.N:IP[0]
                      <"callStack">_N <GHC.Stack.Types.CallStack>_N
                  :: (?callStack::GHC.Stack.Types.CallStack)
                     ~R# GHC.Stack.Types.CallStack)))
      `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
rewrite_args {
  "callStack"
  GHC.Stack.Types.CallStack
rewrite }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [W] $dIP_a9iZ {0}:: GHC.Stack.Types.HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
No local instance for ?callStack::GHC.Stack.Types.CallStack
matchInstEnv
  goal: ghc-prim:GHC.Classes.IP ["callStack",
                                 GHC.Stack.Types.CallStack]
  matches: []
  unify: NoUnifiers
matchClass not matching
  ?callStack::GHC.Stack.Types.CallStack
  instance Backpressure (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Bundle (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Bundle PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Protocols.DfConv.DfConv
             (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance KnownDomain dom =>
           Drivable (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance (KnownNat dataWidth, Eq metaType) =>
           Eq (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Eq PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Functor (PacketStreamM2S dataWidth)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Generic (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Generic PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance KnownNat n =>
           hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
             (BitVector n)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance KnownNat n =>
           hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
             (Index n)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance (KnownNat dataWidth,
            hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
              metaType) =>
           hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
             (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance (KnownNat n,
            hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
              a) =>
           hashable-1.4.4.0-GvBez9LewoxY8y1yrwsNm:Data.Hashable.Class.Hashable
             (Vec n a)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Control.DeepSeq.NFData metaType =>
           Control.DeepSeq.NFData (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Control.DeepSeq.NFData PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance (KnownNat dataWidth, NFDataX metaType) =>
           NFDataX (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance NFDataX PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Protocol (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Show metaType => Show (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance Show PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance ShowX metaType =>
           ShowX (PacketStreamM2S dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance ShowX PacketStreamS2M
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance KnownDomain dom =>
           Simulate (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
  instance (KnownNat dataWidth, NFDataX metaType,
            Control.DeepSeq.NFData metaType, ShowX metaType, Show metaType,
            Eq metaType, KnownDomain dom) =>
           Protocols.Hedgehog.Internal.Test
             (PacketStream dom dataWidth metaType)
    -- Defined in ‘Protocols.Extra.PacketStream’
} matchClassInst global result NoInstance
try_fundeps
  [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 2[l:1,d:0] Kept as inert:
    [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
zonkSimples done:
  {[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9iY {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iD[sk:1] 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_simple =
                   [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  current evbinds  = {[G] irred_a9iY
                        = irred_a9iE
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9iD[sk:1]>_N <1>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9iD[sk:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iD[sk:1] 1) True True False)
                                           (TypeError ...)),
                      [W] $dIP_a9iO
                        = (GHC.Stack.Types.pushCallStack
                             (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "Protocols.Extra.PacketStream.Packetizers"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 7#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 16#))
                             ($dIP_a9iZ
                              `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))}
getHasGivenEqs
  given_eqs: True
  ge_lvl: 0
  ambient level: 1
  Inerts: {Irreds = [G] irred_a9iY {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iD[sk:1] 1) True True False)
                                           (TypeError ...) (CIrredCan(irred))
           Innermost given equalities = 0
           Given eqs at this level = True}
  Insols: {}
solveImplication 2
  {}
  WC {wc_simple =
        [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iD[sk:1] :: Natural)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
    Binds = EvBindsVar<a9iP>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
neededEvVars
  old_needs: {}
  seeds3: {$dIP_a9iZ}
  tcvs: {}
  ev_binds: [a9iY :-> [G] irred_a9iY
                        = irred_a9iE
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9iD[sk:1]>_N <1>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9iD[sk:1] 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iD[sk:1] 1) True True False)
                                           (TypeError ...)),
             a9iO :-> [W] $dIP_a9iO
                        = (GHC.Stack.Types.pushCallStack
                             (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "Protocols.Extra.PacketStream.Packetizers"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 7#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 16#))
                             ($dIP_a9iZ
                              `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a9iO :-> [W] $dIP_a9iO
                             = (GHC.Stack.Types.pushCallStack
                                  (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                     (ghc-prim:GHC.CString.unpackCString#
                                        "Protocols.Extra.PacketStream.Packetizers"#)
                                     (ghc-prim:GHC.CString.unpackCString#
                                        "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                     (ghc-prim:GHC.Types.I# 471#)
                                     (ghc-prim:GHC.Types.I# 7#)
                                     (ghc-prim:GHC.Types.I# 471#)
                                     (ghc-prim:GHC.Types.I# 16#))
                                  ($dIP_a9iZ
                                   `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = (a_a9iD[sk:1] :: Natural)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
    Wanted =
      WC {wc_simple =
            [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
    Binds = EvBindsVar<a9iP>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
solveImplication end }
  has_given_eqs = LocalGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (a_a9iD[sk:1] :: Natural)
                      Given-eqs = LocalGivenEqs
                      Status = Unsolved
                      Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                      Wanted =
                        WC {wc_simple =
                              [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
                      Binds = EvBindsVar<a9iP>
                      the type signature for:
                        bar :: forall (a :: Natural). (a <= 1) => () }
  implication evbinds = {[W] $dIP_a9iO
                           = (GHC.Stack.Types.pushCallStack
                                (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                                 GHC.Stack.Types.SrcLoc
                                   (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                   (ghc-prim:GHC.CString.unpackCString#
                                      "Protocols.Extra.PacketStream.Packetizers"#)
                                   (ghc-prim:GHC.CString.unpackCString#
                                      "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                   (ghc-prim:GHC.Types.I# 471#)
                                   (ghc-prim:GHC.Types.I# 7#)
                                   (ghc-prim:GHC.Types.I# 471#)
                                   (ghc-prim:GHC.Types.I# 16#))
                                ($dIP_a9iZ
                                 `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                             <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                         :: (?callStack::GHC.Stack.Types.CallStack)
                                            ~R# GHC.Stack.Types.CallStack)))
                             `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                              <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                     :: GHC.Stack.Types.CallStack
                                        ~R# (?callStack::GHC.Stack.Types.CallStack))}
  implication tvcs = {}
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iR[sk:1] :: Nat)
    Given-eqs = MaybeGivenEqs
    Status = Unsolved
    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
    Binds = EvBindsVar<a9iW>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
  Inerts {Innermost given equalities = 0
          Given eqs at this level = False}
solveSimpleGivens {
  [[G] irred_a9iS {0}:: a_a9iR[sk:1] <= 0 (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] irred_a9iS {0}:: a_a9iR[sk:1] <= 0 (CNonCanonical)
  inerts = {Innermost given equalities = 0
            Given eqs at this level = False}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] irred_a9iS {0}:: a_a9iR[sk:1]
                                     <= 0 (CNonCanonical)
canEvNC:irred a_a9iR[sk:1] <= 0
can_pred IrredPred =  a_a9iR[sk:1] <= 0
rewrite { a_a9iR[sk:1] <= 0
matchFamTcM
  Matching: GHC.TypeError.Assert
              (a_a9iR[sk:1] <=? 0) (Data.Type.Ord.LeErrMsg a_a9iR[sk:1] 0)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare a_a9iR[sk:1] 0) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare a_a9iR[sk:1] 0
  Match succeeded:
    Rewrites to: CmpNat a_a9iR[sk:1] 0
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9iR[sk:1]>_N <0>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Nat, a_a9iR[sk:1], 0]
  {reductionOriginalType: Data.Type.Ord.Compare a_a9iR[sk:1] 0
    reductionReducedType: CmpNat a_a9iR[sk:1] 0
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9iR[sk:1]>_N <0>_N}
matchFamTcM
  Matching: CmpNat a_a9iR[sk:1] 0
  Match failed
Unfilled tyvar (a_a9iR[sk:1] :: Nat)
matchFamTcM
  Matching: CmpNat a_a9iR[sk:1] 0
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat a_a9iR[sk:1] 0) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
Unfilled tyvar (a_a9iR[sk:1] :: Nat)
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
    (TypeError ...)
addTcEvBind
  a9iW
  [G] irred_a9m3
    = irred_a9iS
      `cast` ((GHC.TypeError.Assert
                 (Data.Type.Ord.OrdCond
                    <Bool>_N
                    (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9iR[sk:1]>_N <0>_N)
                    <True>_N
                    <True>_N
                    <False>_N)_N
                 <(TypeError ...)>_N)_R
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond
                      (Data.Type.Ord.Compare a_a9iR[sk:1] 0) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iR[sk:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iR[sk:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                         (TypeError ...) (CIrredCan(irred))
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat a_a9iR[sk:1] 0)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 3[l:1,d:0] Kept as inert:
    [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat a_a9iR[sk:1] 0) True True False)
                                      (TypeError ...) (CIrredCan(irred))
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-natnormalise
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-knownnat
  given   = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = []
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
End solveSimpleGivens }
solveWanteds {
  Level = 1
  WC {wc_simple =
        [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
simplify_loop iteration=0 (definitely_redo = True, 1 simples to solve)
simplify_loop: wc =
  WC {wc_simple =
        [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
solveSimpleWanteds {
  {[W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1) <= 1 (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1)
                                   <= 1 (CNonCanonical)
  inerts = {Irreds = [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat a_a9iR[sk:1] 0) True True False)
                                            (TypeError ...) (CIrredCan(irred))
            Innermost given equalities = 0
            Given eqs at this level = True}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [W] irred_a9iV {0}:: (a_a9iR[sk:1] + 1)
                                     <= 1 (CNonCanonical)
canEvNC:irred (a_a9iR[sk:1] + 1) <= 1
can_pred IrredPred =  (a_a9iR[sk:1] + 1) <= 1
rewrite { (a_a9iR[sk:1] + 1) <= 1
matchFamTcM
  Matching: GHC.TypeError.Assert
              ((a_a9iR[sk:1] + 1) <=? 1)
              (Data.Type.Ord.LeErrMsg (a_a9iR[sk:1] + 1) 1)
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1) True True False
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1
  Match succeeded:
    Rewrites to: CmpNat (a_a9iR[sk:1] + 1) 1
    Coercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                  <a_a9iR[sk:1] + 1>_N <1>_N
Eager T.F. reduction success
  Data.Type.Ord.Compare
  [Natural, a_a9iR[sk:1] + 1, 1]
  {reductionOriginalType: Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1
    reductionReducedType: CmpNat (a_a9iR[sk:1] + 1) 1
       reductionCoercion: Data.Type.Ord.D:R:CompareNaturalab[0]
                              <a_a9iR[sk:1] + 1>_N <1>_N}
matchFamTcM
  Matching: CmpNat (a_a9iR[sk:1] + 1) 1
  Match failed
matchFamTcM
  Matching: a_a9iR[sk:1] + 1
  Match failed
Unfilled tyvar (a_a9iR[sk:1] :: Nat)
matchFamTcM
  Matching: a_a9iR[sk:1] + 1
  Match failed
matchFamTcM
  Matching: CmpNat (a_a9iR[sk:1] + 1) 1
  Match failed
matchFamTcM
  Matching: Data.Type.Ord.OrdCond
              (CmpNat (a_a9iR[sk:1] + 1) 1) True True False
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: a_a9iR[sk:1] + 1
  Match failed
Unfilled tyvar (a_a9iR[sk:1] :: Nat)
matchFamTcM
  Matching: a_a9iR[sk:1] + 1
  Match failed
matchFamTcM
  Matching: (TypeError ...)
  Match failed
matchFamTcM
  Matching: GHC.TypeError.Assert
              (Data.Type.Ord.OrdCond
                 (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
              (TypeError ...)
  Match failed
rewrite }
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond
       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
    (TypeError ...)
Emitting new wanted
  irred_a9m4 :: GHC.TypeError.Assert
                  (Data.Type.Ord.OrdCond
                     (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                  (TypeError ...)
  arising from a use of ‘bar’
  at src/Protocols/Extra/PacketStream/Packetizers.hs:474:7-9
addTcEvBind
  a9iW
  [W] irred_a9iV
    = irred_a9m4
      `cast` (Sub (Sym (GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             <Bool>_N
                             (Data.Type.Ord.D:R:CompareNaturalab[0] <a_a9iR[sk:1] + 1>_N <1>_N)
                             <True>_N
                             <True>_N
                             <False>_N)_N
                          <(TypeError ...)>_N)_N)
              :: GHC.TypeError.Assert
                   (Data.Type.Ord.OrdCond
                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                   (TypeError ...)
                 ~R# GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond
                          (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1) True True False)
                       (TypeError ...))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...) (CIrredCan(irred))
doTopReact
  [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                         (Data.Type.Ord.OrdCond
                            (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                         (TypeError ...) (CIrredCan(irred))
No local instance for
  GHC.TypeError.Assert
    (Data.Type.Ord.OrdCond
       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
    (TypeError ...)
end stage top-level reactions }
addInertCan {
  Trying to insert new inert item: [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                          (Data.Type.Ord.OrdCond
                                                             (CmpNat (a_a9iR[sk:1] + 1) 1)
                                                             True
                                                             True
                                                             False)
                                                          (TypeError ...) (CIrredCan(irred))
addInertCan }
Step 4[l:1,d:0] Kept as inert:
    [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                           (Data.Type.Ord.OrdCond
                              (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                           (TypeError ...)
End solver pipeline (kept as inert) }
  final_item = [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                      (Data.Type.Ord.OrdCond
                                         (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                      (TypeError ...) (CIrredCan(irred))
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond
                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
  implics = {}
zonkSimples done:
  {[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                          (TypeError ...) (CIrredCan(irred))}
tcPluginSolve start ghc-typelits-extra
  given   = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond
                                       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyExtra
  [NatInequality
   a_a9iR[sk:1]
   0
   True
   Untouched,
   NatInequality
   a_a9iR[sk:1] + 1
   1
   True
   Untouched]
unifyExtra leq result (a_a9iR[sk:1], 0, True)
unifyExtra leq result (a_a9iR[sk:1] + 1, 1, True)
normalised
  Simplified
  Solved:
  []
  New:
  []
tcPluginSolve ok ghc-typelits-extra
  solved = []
  new    = []
tcPluginSolve start ghc-typelits-natnormalise
  given   = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
  wanted  = [[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond
                                       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
simplifyNats
  [(Right ([G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (a_a9iR[sk:1], 0, True)),
    []),
   (Right ([W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                  (Data.Type.Ord.OrdCond
                                     (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                  (TypeError ...) (CIrredCan(irred)),
           (1 + a_a9iR[sk:1], 1, True)),
    [])]
unifyNats(ineq) results
  ([G] irred_a9m3 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   (a_a9iR[sk:1], 0, True),
   -1 * a_a9iR[sk:1],
   [(a_a9iR[sk:1], 0, True)])
normalised
  Impossible Right ([G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iR[sk:1] 0) True True False)
                                           (TypeError ...) (CIrredCan(irred)),
                    (a_a9iR[sk:1], 0, True))
tcPluginSolve contradiction ghc-typelits-natnormalise
  bad = [[G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                (TypeError ...) (CIrredCan(irred))]
tcPluginSolve start ghc-typelits-knownnat
  given   = []
  wanted  = [[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond
                                       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                    (TypeError ...) (CIrredCan(irred))]
tcPluginSolve ok ghc-typelits-knownnat
  solved = []
  new    = []
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                          (TypeError ...) (CIrredCan(irred))
                   [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9iR[sk:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
resetUnificationFlag
  ambient: 1
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_simple =
                   [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                          (TypeError ...) (CIrredCan(irred))
                   [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat a_a9iR[sk:1] 0) True True False)
                                          (TypeError ...) (CIrredCan(irred))}
  current evbinds  = {[G] irred_a9m3
                        = irred_a9iS
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9iR[sk:1]>_N <0>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9iR[sk:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iR[sk:1] 0) True True False)
                                           (TypeError ...)),
                      [W] irred_a9iV
                        = irred_a9m4
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9iR[sk:1] + 1>_N <1>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                              True
                                              True
                                              False)
                                           (TypeError ...))}
getHasGivenEqs
  given_eqs: True
  ge_lvl: 0
  ambient level: 1
  Inerts: {Irreds = [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iR[sk:1] 0) True True False)
                                           (TypeError ...) (CIrredCan(irred))
           Innermost given equalities = 0
           Given eqs at this level = True}
  Insols: {}
solveImplication 2
  {}
  WC {wc_simple =
        [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                               (Data.Type.Ord.OrdCond
                                  (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                               (TypeError ...) (CIrredCan(irred))
        [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                               (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                               (TypeError ...) (CIrredCan(irred))}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iR[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond
                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iW>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
neededEvVars
  old_needs: {}
  seeds3: {irred_a9m4}
  tcvs: {}
  ev_binds: [a9m3 :-> [G] irred_a9m3
                        = irred_a9iS
                          `cast` ((GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        <Bool>_N
                                        (Data.Type.Ord.D:R:CompareNaturalab[0]
                                             <a_a9iR[sk:1]>_N <0>_N)
                                        <True>_N
                                        <True>_N
                                        <False>_N)_N
                                     <(TypeError ...)>_N)_R
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (Data.Type.Ord.Compare a_a9iR[sk:1] 0) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (CmpNat a_a9iR[sk:1] 0) True True False)
                                           (TypeError ...)),
             a9iV :-> [W] irred_a9iV
                        = irred_a9m4
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9iR[sk:1] + 1>_N <1>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                              True
                                              True
                                              False)
                                           (TypeError ...))]
  live_ev_binds: [a9iV :-> [W] irred_a9iV
                             = irred_a9m4
                               `cast` (Sub (Sym (GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      <Bool>_N
                                                      (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                           <a_a9iR[sk:1] + 1>_N <1>_N)
                                                      <True>_N
                                                      <True>_N
                                                      <False>_N)_N
                                                   <(TypeError ...)>_N)_N)
                                       :: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                            (TypeError ...)
                                          ~R# GHC.TypeError.Assert
                                                (Data.Type.Ord.OrdCond
                                                   (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                                   True
                                                   True
                                                   False)
                                                (TypeError ...))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = (a_a9iR[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond
                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iW>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
solveImplication end }
  has_given_eqs = LocalGivenEqs
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (a_a9iR[sk:1] :: Nat)
                      Given-eqs = LocalGivenEqs
                      Status = Unsolved
                      Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                      Wanted =
                        WC {wc_simple =
                              [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                     (Data.Type.Ord.OrdCond
                                                        (CmpNat (a_a9iR[sk:1] + 1) 1)
                                                        True
                                                        True
                                                        False)
                                                     (TypeError ...) (CIrredCan(irred))
                              [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                     (Data.Type.Ord.OrdCond
                                                        (CmpNat a_a9iR[sk:1] 0) True True False)
                                                     (TypeError ...) (CIrredCan(irred))}
                      Binds = EvBindsVar<a9iW>
                      the type signature for:
                        foo :: forall (a :: Nat). (a <= 0) => () }
  implication evbinds = {[W] irred_a9iV
                           = irred_a9m4
                             `cast` (Sub (Sym (GHC.TypeError.Assert
                                                 (Data.Type.Ord.OrdCond
                                                    <Bool>_N
                                                    (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                         <a_a9iR[sk:1] + 1>_N <1>_N)
                                                    <True>_N
                                                    <True>_N
                                                    <False>_N)_N
                                                 <(TypeError ...)>_N)_N)
                                     :: GHC.TypeError.Assert
                                          (Data.Type.Ord.OrdCond
                                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                          (TypeError ...)
                                        ~R# GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                                 True
                                                 True
                                                 False)
                                              (TypeError ...))}
  implication tvcs = {}
solveNestedImplications end }
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_a9iD[sk:1] :: Natural)
                             Given-eqs = LocalGivenEqs
                             Status = Unsolved
                             Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                             Wanted =
                               WC {wc_simple =
                                     [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
                             Binds = EvBindsVar<a9iP>
                             the type signature for:
                               bar :: forall (a :: Natural). (a <= 1) => () },
                      Just Implic {
                             TcLevel = 1
                             Skolems = (a_a9iR[sk:1] :: Nat)
                             Given-eqs = LocalGivenEqs
                             Status = Unsolved
                             Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                             Wanted =
                               WC {wc_simple =
                                     [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                            (Data.Type.Ord.OrdCond
                                                               (CmpNat (a_a9iR[sk:1] + 1) 1)
                                                               True
                                                               True
                                                               False)
                                                            (TypeError ...) (CIrredCan(irred))
                                     [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                            (Data.Type.Ord.OrdCond
                                                               (CmpNat a_a9iR[sk:1] 0)
                                                               True
                                                               True
                                                               False)
                                                            (TypeError ...) (CIrredCan(irred))}
                             Binds = EvBindsVar<a9iW>
                             the type signature for:
                               foo :: forall (a :: Nat). (a <= 0) => () }}
resetUnificationFlag
  ambient: 0
  unif_lvl: Nothing
unif_happened False
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (a_a9iD[sk:1] :: Natural)
                     Given-eqs = LocalGivenEqs
                     Status = Unsolved
                     Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                     Wanted =
                       WC {wc_simple =
                             [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
                     Binds = EvBindsVar<a9iP>
                     the type signature for:
                       bar :: forall (a :: Natural). (a <= 1) => () }
                   Implic {
                     TcLevel = 1
                     Skolems = (a_a9iR[sk:1] :: Nat)
                     Given-eqs = LocalGivenEqs
                     Status = Unsolved
                     Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                     Wanted =
                       WC {wc_simple =
                             [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                    (Data.Type.Ord.OrdCond
                                                       (CmpNat (a_a9iR[sk:1] + 1) 1)
                                                       True
                                                       True
                                                       False)
                                                    (TypeError ...) (CIrredCan(irred))
                             [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                    (Data.Type.Ord.OrdCond
                                                       (CmpNat a_a9iR[sk:1] 0) True True False)
                                                    (TypeError ...) (CIrredCan(irred))}
                     Binds = EvBindsVar<a9iW>
                     the type signature for:
                       foo :: forall (a :: Nat). (a <= 0) => () }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done:
  {[W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
zonkSimples done:
  {[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                          (TypeError ...) (CIrredCan(irred))}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9iD[sk:1] :: Natural)
                    Given-eqs = LocalGivenEqs
                    Status = Unsolved
                    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                    Wanted =
                      WC {wc_simple =
                            [W] $dIP_a9iZ {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
                    Binds = EvBindsVar<a9iP>
                    the type signature for:
                      bar :: forall (a :: Natural). (a <= 1) => () }
                  Implic {
                    TcLevel = 1
                    Skolems = (a_a9iR[sk:1] :: Nat)
                    Given-eqs = LocalGivenEqs
                    Status = Unsolved
                    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                    Wanted =
                      WC {wc_simple =
                            [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                                   (TypeError ...) (CIrredCan(irred))
                            [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      (CmpNat a_a9iR[sk:1] 0) True True False)
                                                   (TypeError ...) (CIrredCan(irred))}
                    Binds = EvBindsVar<a9iW>
                    the type signature for:
                      foo :: forall (a :: Nat). (a <= 0) => () }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
addTcEvBind
  a9iP
  [W] $dIP_a9iZ
    = GHC.Stack.Types.emptyCallStack
      `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iD[sk:1] :: Natural)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iE :: a_a9iD[sk:1] <= 1
    Wanted = WC {}
    Binds = EvBindsVar<a9iP>
    the type signature for:
      bar :: forall (a :: Natural). (a <= 1) => () }
neededEvVars
  old_needs: {$dIP_a9iZ}
  seeds3: {$dIP_a9iZ}
  tcvs: {}
  ev_binds: [a9iO :-> [W] $dIP_a9iO
                        = (GHC.Stack.Types.pushCallStack
                             (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "Protocols.Extra.PacketStream.Packetizers"#)
                                (ghc-prim:GHC.CString.unpackCString#
                                   "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 7#)
                                (ghc-prim:GHC.Types.I# 471#)
                                (ghc-prim:GHC.Types.I# 16#))
                             ($dIP_a9iZ
                              `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack)),
             a9iZ :-> [W] $dIP_a9iZ
                        = GHC.Stack.Types.emptyCallStack
                          `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a9iO :-> [W] $dIP_a9iO
                             = (GHC.Stack.Types.pushCallStack
                                  (ghc-prim:GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (ghc-prim:GHC.CString.unpackCString# "clash-eth-0.1-inplace"#)
                                     (ghc-prim:GHC.CString.unpackCString#
                                        "Protocols.Extra.PacketStream.Packetizers"#)
                                     (ghc-prim:GHC.CString.unpackCString#
                                        "src/Protocols/Extra/PacketStream/Packetizers.hs"#)
                                     (ghc-prim:GHC.Types.I# 471#)
                                     (ghc-prim:GHC.Types.I# 7#)
                                     (ghc-prim:GHC.Types.I# 471#)
                                     (ghc-prim:GHC.Types.I# 16#))
                                  ($dIP_a9iZ
                                   `cast` (ghc-prim:GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack)),
                  a9iZ :-> [W] $dIP_a9iZ
                             = GHC.Stack.Types.emptyCallStack
                               `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = (a_a9iD[sk:1] :: Natural)
                Given-eqs = LocalGivenEqs
                Status = Solved {Dead givens = [irred_a9iE]}
                Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                Wanted = WC {}
                Binds = EvBindsVar<a9iP>
                the type signature for:
                  bar :: forall (a :: Natural). (a <= 1) => () }
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_a9iR[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond
                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iW>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
neededEvVars
  old_needs: {irred_a9m4}
  seeds3: {irred_a9m4}
  tcvs: {}
  ev_binds: [a9iV :-> [W] irred_a9iV
                        = irred_a9m4
                          `cast` (Sub (Sym (GHC.TypeError.Assert
                                              (Data.Type.Ord.OrdCond
                                                 <Bool>_N
                                                 (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                      <a_a9iR[sk:1] + 1>_N <1>_N)
                                                 <True>_N
                                                 <True>_N
                                                 <False>_N)_N
                                              <(TypeError ...)>_N)_N)
                                  :: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...)
                                     ~R# GHC.TypeError.Assert
                                           (Data.Type.Ord.OrdCond
                                              (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                              True
                                              True
                                              False)
                                           (TypeError ...))]
  live_ev_binds: [a9iV :-> [W] irred_a9iV
                             = irred_a9m4
                               `cast` (Sub (Sym (GHC.TypeError.Assert
                                                   (Data.Type.Ord.OrdCond
                                                      <Bool>_N
                                                      (Data.Type.Ord.D:R:CompareNaturalab[0]
                                                           <a_a9iR[sk:1] + 1>_N <1>_N)
                                                      <True>_N
                                                      <True>_N
                                                      <False>_N)_N
                                                   <(TypeError ...)>_N)_N)
                                       :: GHC.TypeError.Assert
                                            (Data.Type.Ord.OrdCond
                                               (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                            (TypeError ...)
                                          ~R# GHC.TypeError.Assert
                                                (Data.Type.Ord.OrdCond
                                                   (Data.Type.Ord.Compare (a_a9iR[sk:1] + 1) 1)
                                                   True
                                                   True
                                                   False)
                                                (TypeError ...))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = (a_a9iR[sk:1] :: Nat)
    Given-eqs = LocalGivenEqs
    Status = Unsolved
    Given = irred_a9iS :: a_a9iR[sk:1] <= 0
    Wanted =
      WC {wc_simple =
            [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond
                                      (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                   (TypeError ...) (CIrredCan(irred))
            [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                   (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                   (TypeError ...) (CIrredCan(irred))}
    Binds = EvBindsVar<a9iW>
    the type signature for:
      foo :: forall (a :: Nat). (a <= 0) => () }
Constraint solver steps = 4
End simplifyTop }
newTcEvBinds unique = a9m5
reportUnsolved {
  type errors: ErrorWithoutFlag
  expr holes: ErrorWithoutFlag
  type holes: ErrorWithoutFlag
  scope holes: ErrorWithoutFlag
reportUnsolved (before zonking and tidying)
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_a9iD[sk:1] :: Natural)
          Given-eqs = LocalGivenEqs
          Status = Solved {Dead givens = [irred_a9iE]}
          Given = irred_a9iE :: a_a9iD[sk:1] <= 1
          Wanted = WC {}
          Binds = EvBindsVar<a9iP>
          the type signature for:
            bar :: forall (a :: Natural). (a <= 1) => () }
        Implic {
          TcLevel = 1
          Skolems = (a_a9iR[sk:1] :: Nat)
          Given-eqs = LocalGivenEqs
          Status = Unsolved
          Given = irred_a9iS :: a_a9iR[sk:1] <= 0
          Wanted =
            WC {wc_simple =
                  [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                         (Data.Type.Ord.OrdCond
                                            (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                         (TypeError ...) (CIrredCan(irred))
                  [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                         (Data.Type.Ord.OrdCond
                                            (CmpNat a_a9iR[sk:1] 0) True True False)
                                         (TypeError ...) (CIrredCan(irred))}
          Binds = EvBindsVar<a9iW>
          the type signature for:
            foo :: forall (a :: Nat). (a <= 0) => () }}
zonkSimples done: {}
zonkSimples done: {}
zonkSimples done:
  {[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond
                             (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                          (TypeError ...) (CIrredCan(irred)),
   [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                          (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                          (TypeError ...) (CIrredCan(irred))}
reportUnsolved (after zonking):
  Free tyvars:
  Tidy env: ([], [])
  Wanted: WC {wc_impl =
                Implic {
                  TcLevel = 1
                  Skolems = (a_a9iD[sk:1] :: Natural)
                  Given-eqs = LocalGivenEqs
                  Status = Solved {Dead givens = [irred_a9iE]}
                  Given = irred_a9iE :: a_a9iD[sk:1] <= 1
                  Wanted = WC {}
                  Binds = EvBindsVar<a9iP>
                  the type signature for:
                    bar :: forall (a :: Natural). (a <= 1) => () }
                Implic {
                  TcLevel = 1
                  Skolems = (a_a9iR[sk:1] :: Nat)
                  Given-eqs = LocalGivenEqs
                  Status = Unsolved
                  Given = irred_a9iS :: a_a9iR[sk:1] <= 0
                  Wanted =
                    WC {wc_simple =
                          [W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                                 (Data.Type.Ord.OrdCond
                                                    (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                                 (TypeError ...) (CIrredCan(irred))
                          [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                                 (Data.Type.Ord.OrdCond
                                                    (CmpNat a_a9iR[sk:1] 0) True True False)
                                                 (TypeError ...) (CIrredCan(irred))}
                  Binds = EvBindsVar<a9iW>
                  the type signature for:
                    foo :: forall (a :: Nat). (a <= 0) => () }}
reportWanteds 1
  Simples = {}
  Suppress = False
  tidy_cts   = []
  tidy_items1 = []
  tidy_errs = []
reportWanteds suppressed: []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  tidy env: ([], [])
  skols:      (a_a9iD[sk:1] :: Natural)
  tidy skols: (a_a9iD[sk:1] :: Natural)
reportWanteds empty WC
reportImplic
  tidy env: ([], [])
  skols:      (a_a9iR[sk:1] :: Nat)
  tidy skols: (a_a9iR[sk:1] :: Nat)
reportWanteds 1
  Simples = {[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond
                                       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                    (TypeError ...) (CIrredCan(irred)),
             [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                                    (TypeError ...) (CIrredCan(irred))}
  Suppress = False
  tidy_cts   = [[W] irred_a9m4 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                       (TypeError ...) (CIrredCan(irred)),
                [G] irred_a9m3 {0}:: GHC.TypeError.Assert
                                       (Data.Type.Ord.OrdCond
                                          (CmpNat a_a9iR[sk:1] 0) True True False)
                                       (TypeError ...) (CIrredCan(irred))]
  tidy_items1 = [[W] irred_a9m4 :: GHC.TypeError.Assert
                                     (Data.Type.Ord.OrdCond
                                        (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                     (TypeError ...),
                 [G] GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                       (TypeError ...)]
  tidy_errs = []
reportWanteds suppressed: []
tryReporters {
  [[W] irred_a9m4 :: GHC.TypeError.Assert
                       (Data.Type.Ord.OrdCond
                          (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                       (TypeError ...),
   [G] GHC.TypeError.Assert
         (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
         (TypeError ...)]
  []
tryReporter{ 
  custom_error [[W] irred_a9m4 :: GHC.TypeError.Assert
                                    (Data.Type.Ord.OrdCond
                                       (CmpNat (a_a9iR[sk:1] + 1) 1) True True False)
                                    (TypeError ...),
                [G] GHC.TypeError.Assert
                      (Data.Type.Ord.OrdCond (CmpNat a_a9iR[sk:1] 0) True True False)
                      (TypeError ...)]
Adding diagnostic:
  src/Protocols/Extra/PacketStream/Packetizers.hs:474:7: error: [GHC-64725]
      • Cannot satisfy: a + 1 <= 1
      • In the expression: bar @(a + 1)
        In an equation for ‘foo’: foo = bar @(a + 1)
Adding diagnostic:
  src/Protocols/Extra/PacketStream/Packetizers.hs:473:1: error: [GHC-64725]
      Cannot satisfy: a <= 0
tryReporter end } custom_error False True
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
mkTypeableBinds []
Tc9
tcPluginStop ghc-typelits-extra
tcPluginStop ghc-typelits-natnormalise
tcPluginStop ghc-typelits-knownnat
